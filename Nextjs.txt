0:00
do you remember when building a website felt like constructing the Great Wall of China weeks of hard work endless setup
0:07
and a maze of steps just to get a simple page online times have changed thanks to
0:12
updates in the tech we use you can now host a full-blown Miracle Within hours
0:18
to avoid spending time on configuration linting compilation bundling and deployment developers wanted no deserved
0:26
a framework that would streamline things meet next year a framework that just
0:31
works gets out of your way and lets you do your thing in 2013 Facebook
0:36
introduced react a groundbreaking technology that revolutionized web development and created countless job
0:43
opportunities fast forward to today and believe it or not the official react documentation now suggests never to use
0:50
plain react again instead it recommends building apps using a production grade
0:55
full stack react framework nextjs first I'll lead you through a crash course to
1:01
explain and visualize essential nextjs Concepts like architecture rendering routing and its full stack features then
1:08
together we'll explore those Concepts directly within the code and finally I'll put your skills to the test by
1:14
teaching you how to build an Enterprise ready application YC directory now this
1:20
crash course will give you a great Foundation but if you're serious about mastering nextjs and taking your skills
1:25
to a professional level I've got something special for you the ultimate next GS S course where we go beyond the
1:32
basics and tackle next gs's most advanced Enterprise grade features is
1:37
now on sale you'll learn everything from optimizing performance and SEO to serverless architecture and handling
1:44
realworld production challenges to become a full stack production ready developer check the description for more
1:51
details on how to enroll if you're wondering if all companies are shifting to NEX GS and whether it's even worth
1:56
learning the answer is a resounding yes at this point what major company isn't
2:02
using nextjs big names like Netflix Tik Tok twitch Hulu notion Nike and even
2:08
open AI are building their websites with it the nextjs hype is real and if you
2:13
don't dive in now you could miss out on some life-changing opportunities so now is the perfect time to impress potential
2:20
employers and show them you mean business and how are you going to do that by actually building your own full
2:27
stack NEX GS app that's packed with Enterprise features like performance and speed optimizations to achieve Lightning
2:34
Fast first contentful paint SEO optimization and server side rendering strategies for high search engine
2:40
rankings centuries performance tracking allowing you to monitor your app in real time identify bottlenecks and resolve
2:47
user issues quickly improved developer experience to ship apps faster a serverless architecture that will allow
2:53
you to scale your apps easy management of all your apps content using sanity
2:59
I'll also teach you how and when to implement CDN caching for improved performance and much more to always have
3:05
employers knocking at your door but now have you heard of why combinator that famous startup accelerator that gave
3:12
birth to so many popular apps we use every day like stripe Airbnb twitch
3:17
coinbase and even Reddit today you'll build your version allowing users to
3:22
create and share their startup with the world once they submit it it appears instantly without needing to reload the
3:28
page they can also search by title username or category to get instant results once you find the startup you
3:34
like you can navigate to its details and see how many other people have found it interesting before you you'll integrate
3:40
GitHub authentication via next off so users can log in create and submit
3:45
startups with markdown support with a dedicated profile page where you can find all other startups from that user
3:52
you'll Implement all that using the latest nextjs features like PPR next
3:57
after new forms server component HMR cache and server actions you'll also
4:02
learn how to use the sanity content operating system an API based platform for structured content that pairs
4:08
perfectly with NEX GS and other popular front-end Frameworks that companies like Shopify puma figma and tag group use to
4:15
manage their content it lets you skip the boring Parts allowing you to focus on what truly matters bringing your
4:21
project to life sanity is doubling down on its role within the next GS ecosystem it has a very generous free tier and no
4:28
credit card is required even better you'll get a free upgrade just because you're watching this video click the link in the description click get
4:35
started go through a quick onboarding and you'll get your free upgrade so what are you waiting for let's dive right
4:41
into the wait I have some breaking and exclusive news webstorm just became free
4:47
yep you've heard that right that professional web focused IDE with tons of features that used to cost like a
4:55
hundred bucks per year is now completely free for non-commercial use and I'm not talking about a free trial or freemium
5:02
but completely free I've been using webstorm for a long time and love its speed search G integration inline type
5:09
suggestions and more so if you're a student hobbyist still learning or contributing to open source you can out
5:15
try out all of those fancy features that used to be paid and prevented you from using this powerful IDE click the link
5:22
in the description and try out webstorm today
Next.js Benefits
5:30
let me start with a very important first question what does nygs have that react
5:36
doesn't in simple terms nextjs simplifies the development process and
5:41
optimizes your applications it does that through its primary functionalities some of which you have to actively decide to
5:47
use and others that you get out of the box just by switching to nextjs along with the course I've also prepare the
5:54
ultimate next gsse book think of it as a handbook that covers everything you need to know to become a Prof professional
5:59
nextjs developer from the nextjs road map Concepts and features to Advanced
6:05
tips and tricks for building scalable projects you can build and deploy to put on your portfolio it's a premium and
6:11
paid ebook with over 200 pages but I've made it entirely free for the first
6:16
1,000 developers that downloaded clicking the link in the description so don't miss out the first of NEX gs's
6:22
benefits is its architecture originally react had two types of components functional and class-based components
6:29
but now components are also categorized by where they run if a component runs in the user's browser it's called a client
6:36
component and if it runs on the server it's called a server component this division was released in react 19 and
6:43
although Frameworks Like Remix and asro also supported nextjs was the first to adopt it and fully utilize it since
6:50
server components are more performant nextjs automatically converts every new component you create into a server
6:56
component unless you specifically instructed not to only if you need some browser functionalities but more on that
7:02
later the second nextjs benefit is in the way it handles rendering while react
7:07
19 supports server components nextjs extends them to more advanced rendering
7:12
strategies allowing you to choose exactly where and when they'll be rendered optimizing the performance even
7:17
further first is client side rendering which happens on your browser the server sends a basic HTML document and
7:24
JavaScript code which the browser executes to render the components and display the website and the second is
7:30
serers side rendering which involves rendering the web page on the server before transmitting it to your browser
7:36
when you visit a page the server processes and renders the components on the server and sends back fully rendered
7:41
HTML and JavaScript code to the client instantly displaying the website but why does this matter well on top of the fact
7:48
that your website will load in 300 milliseconds and have page speed insights that look like this service
7:54
side rendering will significantly improve your website's search engine optimization client side rendering makes
7:59
it almost impossible for search engines to crawl and index your websites as they're completely empty nextjs solves
8:06
this issue by sending pre-rendered code giving Google plenty of stuff to rank us on the next big nextjs benefit is of
8:12
course routing in react you need to install an additional react router package to create routes on the other
8:18
hand nextjs doesn't require installing a separate routing package and uses a much more intuitive approach to routing
8:25
called file based routing each folder's name becomes a routes path for example a
8:31
folder named about will create a new slab route super simple right and
8:37
connecting directly to the routing system the next best thing about NEX GS is its Evolution from a simple frontend
8:43
library to a full stack framework using the same file-based routing system I just described you can also create
8:49
serverless functions to handle native backend API requests this means you can
8:54
create an API endpoint by simply creating a file called route. Js in a specific folder without needing to worry
9:01
about the server infrastructure NEX GS takes care of scaling automatically and there are many other scaling features
9:07
that NEX GS provides out of the box like automatic code splitting while code splitting in react is possible it
9:14
requires manual configuration especially as the application grows next GS automates code splitting by default well
9:20
what does that mean it means that when a user navigates to a different page only the code for that page is loaded which
9:26
significantly speeds up page load times pretty handy right but that was just one out of many built-in performance
9:32
optimizations that NEX GS provides font optimization reduces layout shift improves loading Time by pre-loading
9:38
font files and reduces Reliance on external services like Google fonts image optimization automatically
9:45
compresses images and applies lazy loading CDN support and more script optimization optimizes even thirdparty
9:52
scripts and all of these gr optimizations come right out of the box with nextjs and it's not just
9:57
performance nextjs is the definition of Cutting Edge it supports the latest features such as react compiler MDX file
10:04
integration managing most SEO related tags analytics that run without blocking UI fast refresh server components hot
10:11
module replacement and more oh I know that was a lot right if you want me to slow down a lot and provide you with a
10:18
deeper understanding of all of these Concepts like architecture and rendering I'd highly recommend checking out the
10:23
ultimate nextjs course it covers all important Concepts spread out throughout many modules and individual ual lessons
10:30
and more importantly it also includes active lessons which require you to actively apply what you've learned up to
10:35
this point the ultimate next GS course has secured its place as the best nextjs course in the world and from today it
10:42
just got updated to the latest nextjs version so check it out in the description with that said if you're not
10:47
ready to get that course yet that's totally okay stay with me and I'll teach you everything I know about next GS in
10:53
this crash course to get started create a new empty folder on your desktop and
Next.js Theory & Practical
10:58
open up your terminal once you're there run MPX
11:03
create-- apppp add latest and press enter after that press y to install the
11:10
installer and you'll be prompted to answer a couple of questions for the project name just type do slash because
11:16
we're already in the folder within which we want to create our nygs app in this case say yes for typescript yes for
11:23
eslint yes for tailin CSS in this case we don't need a source directory we
11:28
definitely will be using the app router with its latest functionalities as well as the turbo pack which runs your
11:35
application more smoothly we don't need to customize the import Alias the default one is fine and that's it your
11:41
application will soon get initialized with all of the dependencies needed to run it there we go that was a success
11:48
now that your project is set up and ready to go you'll notice many fs and folders so let me walk you through them
11:55
from bottom to top the first one on our list is TS config f.j Json this is the
12:01
configuration file for typescript it defines what should be type checked ignored and the rules to follow next we
12:09
have a Tailwind doc config.txt Tailwind by customizing
12:16
colors sizes Shadows plugins or anything else you might need you know about read me right it's a simple marked done file
12:23
that explains how to run the project next we have a post CSS config MJS it's
12:28
a configuration file for post CSS a tool used to process CSS with different
12:33
plugins in this case it uses tailin CSS as a plugin which allows you to use
12:38
utility first classes in your project package lock Json is a file that locks
12:44
the version of dependencies and their
12:49
subpena same versions package Jon is a bit simpler and it contains all the
12:54
current dependencies and scripts there's a Dev script which starts nextjs in development mode with hot module
13:01
reloading error reporting and more build creates an optimized production build of your app starts simply starts next GS in
13:09
production mode and there's also lint which runs es lint for all files in the source app directory and more finally
13:16
you can also see three very important dependencies react react Dom and the
13:22
current version of next by the time you're watching this video you should just be able to see 15 right here after
13:29
after package Jon we have a next env. D.S which is a typescript declaration
13:34
file for nextjs and as it says right here this file should not be edited it's specifically for
13:40
nextjs on the other hand next.
13:46
config.sys features such as experimental options image settings build settings
13:52
and more and you all know the good old get ignore it's very important not to miss adding something there thankfully
13:58
next JS adds the EnV for us that's good no more leaked environment variables
14:04
after that we have a lint rc. Json allowing you to configure your linting options then we dive into folders first
14:11
we have a public folder which contains static assets always put your images and
14:17
other static data here and then of course there's the node modules the heaviest object in the universe Jokes
14:24
Aside it is a folder containing all the dependencies or packages needed to run
14:29
your application and finally there's the app folder the most important folder in
14:35
every nextjs application in the app folder of course we have our primary homepage page. DSX but before we check
14:43
out the rest of these pages in detail let's first run our application to see it in the browser I'll open up the
14:49
terminal and press mpm run Dev this will run it on Local Host
14:55
3000 so open it up there we go nextjs get started by editing app page. DSX
15:03
save and see your changes instantly well this is the new version of the boilerplate page I like it you'll also
15:09
notice something at the bottom left I'll tell you what that is later on but for now the page you've just seen is right
15:15
here within page. DSX this file represents the homepage or the forward
15:21
SL route of your site by default it contains some boilerplate code so let's
15:26
remove it and return a single H1 that says welcome to next.js we can also give
15:33
it a class name of text- 3XL if I save it and go back to the browser you'll see
15:40
the changes instantly thanks to HMR hot module replacement among the other
15:45
folders that we have here the first one are fonts and this is where you can store your font files it's actually
15:51
preferable to using something like Google fonts think of it as self-hosting your own fonts there's a favicon Ico
15:59
it's a file that appears on your browser's tab then there's the global. CSS file where you can write all of your
16:05
custom CSS or simply import tailin CSS after that we have a layout. DSX this is
16:13
the main entry point for your application anything you do here will be applied across all pages and routes
16:19
that's why here we're importing the fonts the Styles and the metadata for
16:25
example let's change the metadata from create next app to something like hello
16:31
nextjs I've even added a waving emoji and even without reloading you can see
16:37
the changes in your browser and I know many of you will wonder what kind of browser is this I'm using Arc you can
16:42
check it out I like it quite a lot and finally we're getting back to the page. TSX where we initially made those
16:48
changes that's it that's the most important folder of your app and all of the changes that you make to your app
16:53
will go inside of this app folder okay okay now that you're familiar with the
16:59
entire nextjs application structure let's get our hands dirty at the start of the crash course I was telling you a
17:05
bit about architecture where you can write two different types of components client and server components if you
17:12
remember I said that every component you create nextjs will by default turn into
17:17
a server component but is that really the case here on the homepage we have a component saying welcome to nextjs let's
17:25
add a conso log before the return statement consol log what am I I was
17:32
about to start what am I server or client component but it looks like our AI autocomplete is having a bit of an
17:38
existential crisis it's saying what am I doing here but yeah I'll just add server
17:44
or client let's see which type of component is this by default we have
17:50
absolutely nothing here just export default function home where we have a consol log and an H1 statement where do
17:56
you think this consol log will appear do you think will be able to see this conso log in the browser well up to this point
18:02
I would tell you no it's not going to appear in your browser because this is a serverside component but would you look
18:08
at this xgs steam knew that some of us might be searching for this cons log in the browser so even though technically
18:15
it shouldn't be showing here they're still showing it to us but they have added this server tag at the top left so
18:21
we know it's actually rendering from the server pretty cool nextjs but if you actually knew what you were doing you
18:28
would IM immediately go to the terminal to find your console log and here it is
18:33
so now we know that this is actually rendering on the server server components are rendered on the server so
18:40
this brings me to the topic of react server components they're the components that are rendered on the server and
18:46
their HTML output is then sent to the client since they're rendered in the server they can access serverside
18:53
resources directly like databases or defile system this helps reduce the
18:58
amount of JavaScript sent to the client improving performance server components are excellent when you need direct
19:05
access to serers side resources like accessing files in a file system or you
19:10
want to keep sensitive information well sensitive such as access tokens and other Keys safe on the server all right
19:18
but if server components really are better why can't everything be a server
19:23
component well if your component requires browser interactivity such as clicking buttons navigating to different
19:30
pages and submitting forms then you need to turn it into a client component so
19:36
what are react client components client components are of course rendered on the
19:41
client side and in this case client side simply means the browser to use them in
19:47
nextjs you must add a use client directive at the top of the component in our case let's do that by creating a new
19:55
folder within the app folder and call it components and within it create a new file called
20:01
hello. DSX right at the top you can add that use client directive that I was telling
20:08
you about and then you can simply create a new functional component called hello
20:13
that simply returns a div with an H1 that says hello and I've also added a
20:19
console log saying I am a clan component see this one doesn't have an existential
20:25
crisis it knows what it is now that you've created it let's go back to the page. TSX let's wrap this H1 within a
20:32
react fragment allowing us to add another adjacent element in this case we'll
20:38
simply import the hello component coming from at SLA SL components SLO now let's
20:46
check the terminal okay we don't see that conso log there but that makes sense right because hello knows it's a
20:54
client component but if we go into the browser there we go I am I am a client
20:59
component coming from hello. DSX but wait I think I initially missed it but
21:04
now I see it I am a client component is so confident that it appears right here too but why or how is that happening
21:12
well this is because server components are rendered only on the server side while client components are pre-rendered
21:20
on the server side to create a static shell and then hydrate it on the client
21:26
side this means that everything within the the client component that doesn't require interactivity or isn't dependent
21:33
on the browser is still rendered on the server the code or parts that rely on
21:38
the browser or require interactivity are left as placeholders during server side
21:44
pre-rendering when they reach the client the browser then renders the client components and fills in the placeholders
21:51
left by the server I hope that makes sense and that answers the question of what is serers side pre-rendering a
21:58
pretty cool feature by nextjs I hope that's clear now but if you're still unsure take a second to pause it and
22:05
rewatch it until it clicks you can also add some additional cons logs or components and then render them within
22:11
the page. DSX don't proceed further if that doesn't make sense and for a deeper
22:16
dive with clearer explanations and more visuals I would recommend checking out the ultimate nextjs course where I break
22:23
down the entire client server architecture in detail so finally when
22:29
should you allow nextjs to turn your components into server side components and when should you manually change them
22:35
to client side well A good rule of thumb is to leave it as server side component
22:40
until you need some browser interactivity at which point you'll most likely get an error and then you can add
22:45
the use client directive at the top but if you want to understand on a deeper level when should you use each one
22:52
always refer to this table within the nextjs docs I'll make sure to link it as an essential resource within the ebook
22:58
that you can download this is the best table that simply explains when you need something to be a server or a client
23:04
component depending on what you need that component to do now it's time to dive into routing nextjs uses a file
23:12
based routing system and doing everything on a single page is boring right currently we only have one route
23:18
which is the homepage so how do we create a new route like forward
23:24
slab it is as simple as creating a new folder and a file in the app directory create a new folder
23:32
and name it about and within that folder create a new page. TSX file within there you can
23:39
create a single functional component that returns a div that says about now go back to the browser and simply add
23:47
for slab to your URL and if I zoom it in a lot there we
23:54
go the route is being displayed this is how you create routes in xgs it uses an
24:01
intuitive file-based routing system where folders are used to define routes
24:06
the folder name becomes the route name and the page that the aect inside of it becomes a file that gets rendered for
24:13
that route it's a special file naming convention for displaying that route's content but in most cases that won't be
24:20
enough you'll need nested routes let's say you're developing an admin dashboard within this application and you want to
24:26
create a Route 4 dashboard users and dashboard analytics of course you can't
24:33
create two folders with the same name this is where nested routes come in handy let's create a new folder called
24:40
dashboard inside of which we'll create two additional folders one will be
24:45
called users and another one will be called analytics and both of them will
24:51
contain a special page. DSX file there we go you get one and you get one too
24:59
within them we can simply run our afce if you don't have that Quick Command you can install it as a package it's called
25:06
react Snippets and then within this one we can call it users we can duplicate that and we can
25:12
also add it within analytics and if you go back to your browser go to forward SL
25:18
dashboard slash users you can see users and if you go to/ analytics you can see
25:26
analytics but of course if you go just to dashboard itself it's going to be a 404 here's a quick question for you do
25:33
you know how you would create a separate dashboard homepage if you wanted to the
25:39
answer is simply add another page. DSX within the dashboard folder itself yes
25:45
you can have a dashboard page and then dashboard nested routes but this still
25:50
may not be enough in many cases you'll also need Dynamic routes what if you
25:56
want to display each user's profile in the dashboard let's say we have four
26:01
predefined users in the dashboard users page that's going to look something like this users with in div and then we have
26:08
an H1 and a UL with four different users now let's say you want to show full user
26:13
details on the page when you click on each one of these users say we want to direct them to dashboard users user one
26:21
and then dashboard users user 2 and so on we can't create these folders
26:27
manually as we don't know how many users will there be this is what dynamic routing is all about a route where part
26:35
of the URL can change or be dynamic typically based on the user input or
26:40
specific data in the database creating Dynamic routes in nextjs is simple all
26:46
you have to do is wrap the part that changes that is dynamic in square brackets in our case it'll be the user
26:53
ID so let's create a new folder called ID within the users folder and make sure
27:01
to wrap it within square brackets that's the rule inside of that file create a
27:06
new page. TSX and run RFC to create a
27:12
generic user Details page now let's go back to the users page
27:18
and let's make these users clickable doing that is pretty simple we just have to use NEX gs's link
27:26
component it looks like this you import it from next SL link you give it an hre
27:33
to where you want to go and in this case let's make it point to dashboard slash
27:39
users slash1 and let's say user one we can of
27:45
course duplicate this a few more times so let's put it within an Li and
27:50
properly close it and 1 2 3 there we go and we can also
27:57
change their name GES 2 3 4 now if I go back to the browser I can actually click
28:03
on these links and look they let me to the user Details page but they all do
28:09
right three four they're all relating to the same user Details page or the page
28:16
is technically different because right here you can see it says users one and if you go to users 2 it's going to say
28:22
users 2 but how do we extract the different information about each one of the the users let me show you I'll go
28:30
back to user Details page and we can extract this Dynamic parameter from the
28:36
folder from the params object you destructure right here at the top of the
28:41
function and then you say params since we're using typescript we also need to define the type of the params it'll be
28:48
an object containing a single ID which will be of a type string and how do I know that it will contain a single
28:54
property called ID of a typ string well that's because we called this Dynamic route ID by saying ID within square
29:03
brackets if you said something like name here you would be able to extract it by saying something like name in this case
29:10
let's destructure the ID from pams by saying const ID is equal to pams or you
29:17
can also use the dot notation saying pam. ID finally now we can say user profile
29:25
and then we can show the actual ID let's actually turn this into H1 and give it a
29:31
class name of text- 3XL so we can see it better now if you go back you can see
29:37
user profile 2 user profile 3 4 and so on and in real life this would work
29:44
exactly the same you will always be fetching just the user ID but then from
29:49
that page you can make a call to the database that'll give you all the other user information such as their Avatar
29:56
full name username and more more so now you know what prams are and if you want
30:01
to get access to this information such as this ID elsewhere and not within an xgs page you can use a client component
30:09
hook called use params that lets you read routes Dynamic parameters filled in
30:14
by the current URL next let's learn about layout earlier I told you that the
30:19
layout. TSX file is the main starting point of our app to demonstrate this let
30:25
me add a text of root before run in the children I'll do that right here and
30:31
once again I'll make it H1 with a class name of text- 3XL and
30:38
I'll say root now if you check out the homepage it'll say root welcome to nextjs then if
30:45
you go to slab you'll see root about or if you go to dashboard SL users if it
30:53
doesn't appear automatically for you you might need to reload your server by opening up the ter Al pressing contrl C
31:00
to stop it and then rerunning mpm runev but you get the point rout appears on
31:06
top of all the pages this is because layout. TSX acts as the parent for all
31:12
of these routes it allows you to share UI elements across multiple Pages for
31:19
example you can place features like a navbar or a footer in the layout and
31:25
they'll appear on all children routes saving you you from having to import them on every page simply add them once
31:32
in layout. TSX and they'll be available wherever needed in nextjs a root layout
31:38
is always required but you can create additional layouts if necessary let's say you want to render a
31:45
specific UI just for the dashboard routes we can do that by adding another
31:52
layout. TSX right here within the dashboard the name has to be layout
31:58
don't try something else otherwise nextjs won't recognize it creating a new layout is as simple as creating a new
32:05
functional component and then getting children right here just to make typescript happy you can also Define
32:12
additional types such as children is equal to react node and you might need
32:17
to import react there we go now everybody's happy within this div we can then render
32:23
children and the children in this case will be all other pages that you showing within this layout but if you want to
32:31
add some kind of a special dashboard nav bar so let's say dashboard then you can
32:36
add it to the layout and let's also apply the same styles by giving it a class name equal to text- 3XL so now if
32:44
you reload you can see root this is coming from the root layout and then dashboard is coming from the dashboard
32:51
layout just imagine that these are different pieces of the UI that we're showing on different screens so
32:57
dashboard users and dashboard analytics has both root and dashboard but as soon
33:02
as you exit the dashboard route group you're back to just rout I hope this makes sense but there's more route
33:11
groups let's say you don't want the rot layout to appear in the dashboard routes
33:16
and only show up in non dashboard routes like home about and more this means that
33:22
you'd need a separate nav bar for the dashboard and another one for the non- dashboard routes that's pretty similar
33:28
how things work in real life right in such scenarios you can use route groups
33:34
they allow you to organize your route segments and project structure without impacting the URL path this means that
33:42
you can create folders but unlike nested routes they won't show up in the URL you
33:47
do that by wrapping the folder name inside parentheses in our case let's create two different folders one will be
33:55
called dashboard in parentheses and the other one will be called root in
34:00
parenthesis as well now move the dashboard folder within the dashboard in
34:06
parenthesis and move the homepage and the about folder in the
34:11
root now remove the root from the root layout file this let's say this is a
34:17
root navigation bar and add another layout. TSX file within the root route
34:23
group once again it is a single functional component that accepts children and then now you can render the
34:31
nav bar right here so let's do an H1 and this case let's give it a class name
34:36
equal to text- 3XL and let's simply say navbar and you must render children in
34:43
every layout file so let's render them below and one last change is to move the
34:48
layout. TSX from this dashboard folder to this dashboard folder right
34:55
here now each route group has its own layout now if you go back to
35:01
the website you'll see everything is as it was we have nav bar on top of the
35:06
home and slout Route and if we go to dashboard and then users you can see
35:13
that we have only a dashboard navigation bar everything works as expected so why
35:18
are we using these route groups in the first place well take a look they're making our code more organized without
35:26
affecting the URL to go to the homepage or to the about page you don't have to say forward SL
35:32
root forward slab you simply say about so whenever you place a folder name
35:38
within parenthesis that means you're creating a route group and it will not be map to a URL path and why is this
35:46
useful well one for organizing your code you can see everything is cleaner now
35:51
and the second reason is that you can have separate layouts for different route groups which are going to give you
35:57
different UI but without affecting the URL so let's rewind one more time route
36:03
groups allow you to create folders without affecting the URL and even
36:08
though creating route groups isn't taken into account you can still create files like layout. DSX inside of them and it's
36:16
important that this Ru route group still points to the homepage so this page right here is the primary homepage if
36:23
you were to copy and paste this file into the dashboard that would work because now we have two parallel routes
36:31
that resolve to the same path I hope this is clear understanding route groups is extremely useful because they allow
36:38
you to separate concerns manage route segments and render content properly all
36:44
without showing them in the URL next let's talk about airor handling in
36:49
nextjs there's a special file called error. JS or TS if you're using
36:55
typescript that catches errors and and displays them on the UI similar to how
37:00
we were able to create multiple layout files for each folder be that a route group or a route folder we can do the
37:07
same for the error. TS file let's throw an error on purpose in the about page
37:12
I'll head over to that page and I'll say Throw new
37:17
error I'll say something like not implemented and don't forget to delete
37:23
this duplicate of a p TSX within the dashboard that one is still throwing as the old error once you do that and go to
37:30
about you'll see an error that is fine for as developers but you never want to
37:35
show it to the end user rather if there has to be an error let's show it within a nice UI at least the user will feel
37:42
better that way to do that let's create a new error. TSX file in the root
37:49
folder error. TSX in it I'll copy the code provided to us by the next year's
37:55
documentation this component is is nicely handling the error save and
38:00
revisit the about page check it out we don't see that red popup anymore rather
38:06
we see what we have implemented in the error. TSX file something went wrong try
38:12
again super simple and straightforward to handle errors in xgs right and as I
38:17
said you can even create these error files specific to different routes if you just want to have one Global error
38:24
then you can do it by creating a global error TSX file in the root of the app
38:29
folder that's going to look something like this I'll go into the app and create a new file called
38:36
Global error. TSX the code will look something like
38:43
this I'm not sure why my indentation is not working when copying but you get the idea you can specify the HTML and the
38:51
body and simply show some kind of an error take a note that error boundaries must be client comp components now going
38:58
back to our app can we see this error well not really unlike layout. TSX which
39:05
displays everything from its parent the error file Works differently only the closest error file
39:12
to the route takes priority meaning you won't see the content both from Global
39:18
a. TSX and from the root error TSX errors will bubble up to the nearest
39:24
parent error file not all of them make sense and to talk about something else other
39:30
than errors let's talk about loading uis loading uis in nextjs works very
39:37
similarly to error handling you want to show some kind of a loading progress while data is being fetched for users
39:44
with a slow internet connection it is as simple as adding a new loading. TSX file
39:52
in the folder in there you can create any kind of a loader or a Nic looking
39:58
spinner now as your page reloads this file will show I'll keep reloading the
40:03
screen so you can see that loading bar adding loadings to your nextjs really doesn't get simpler than that while the
40:09
data is loading nextjs will show the content you specified in the loading file and once the data is received the
40:17
content in the page you're trying to render will be shown it's super useful and surprisingly easy to do I've covered
40:23
this in more detail in the ultimate nextjs course as you can see here there's an entire section dedicated to
40:30
it complete with challenges to help you practice but in this crash course you'll
40:35
also see this in action in the next segment where we'll actually do some real world data fetching and in addition
40:41
to these main file conventions like page layout error and loading nextjs also
40:48
provides other features like parallel routes intercepting routes and localization routes that display content
40:54
based on the user's language you can explore all of these in the next GSS documentation but for now let's move
41:02
over to data fetching the most interesting Concept in nextjs there are
41:08
different ways in which we can fetch content a traditional way is using a use
41:13
effect for example this is what you would do let's say that you have a homepage where you're trying to set and
41:20
fetch some albums you create a new empty use State you declare a use effect
41:26
Within which you declare an asynchronous fetching function within it you have an await
41:33
fetch where you're trying to get some albums and then you return that Json and set it to the state finally going a bit
41:41
down you map over those albums and show the data but this isn't super efficient
41:47
there is a better alternative to fetch and it's happening on the server side not only is it faster and more efficient
41:55
the code is also so much cleaner check this out you declare a new functional component called home and immediately on
42:02
top of it you make a fetch request you check if it fails if it doesn't you
42:07
simply declare it and set its response. Json to the album's variable you map
42:13
over it and display the details go ahead pause this video and test it out you
42:19
don't necessarily have to do all the Styles but you can at least try to fetch the data map over the albums and show
42:26
each album title if you do it visit the website and see if it works you'll not
42:31
see anything you'll have to refresh to see the result and it's not because HMR
42:37
is not working but rather HMR is caching your content in latest versions of
42:43
nextjs there is a new feature called server components HMR cache that allows
42:49
you to cash fetch responses in server components across hot module replacement
42:55
refreshes in local development ment what this means is you'll have faster responses and reduced costs for build
43:02
API calls but now coming back to the difference between server side fetching versus client side fetching first of all
43:10
you'll notice the code difference between the two strategies with server side fetching you wrote fewer lines of
43:16
code which improves the DX developer experience but that's not the only
43:22
benefit server side fetching has so many more benefits like improved initial low
43:27
time as a server side data fetching allows the page to be rendered with the data already included it reduces the
43:34
time to First contentful paint FCP in the client side example the user sees an
43:41
empty page until the data is fetched and then rendered the second and most important benefit of server side
43:47
fetching is better SEO search engine crawlers can more easily index content
43:54
rendered on the server as the content is already provided in HTML
43:59
format in contrast client side fetching may result in content not being visible
44:05
to crawlers right away since it first needs to be fetched and then displayed on the UI which can negatively impact
44:12
your SEO next not only is the code shorter but the logic is
44:19
simplified server components allow you to keep data fetching Logic on the server closer to your data source this
44:26
can simplify your component logic and reduce the need for use effect and use State Hooks and the next benefit is not
44:33
that easy to understand that first and it is automatic request D duplication
44:39
nextjs provides that automatic request D duplication when fetching data on the server which can improve performance and
44:46
reduce unnecessary API calls basically request the duplication makes sure that
44:52
when the same data is requested multiple times at once only one request is sent
44:58
it stops duplicate requests from being made and when talking about benefits of
45:03
the server side fetching versus client side fetching I really can't miss on
45:08
improved security keeping API calls on the server allows you to better protect
45:14
sensitive information like API Keys which should never be exposed on the client side and adding to the list of
45:21
benefits we have reduced Network waterfall client side data fetching
45:26
often leads to to a network waterfall where requests are made sequentially server side fetching can more
45:32
efficiently parallelize those requests I'll teach you how to do these parallel requests in our build and deploy project
45:39
so keep watching but this isn't just about fetching you can server render any
45:44
other calls maybe a direct database call to Prisma to get the list of posts or
45:50
even with Mongoose and mongodb like this that's the beauty of nextjs this is achievable because these
45:57
components are react server components which allow you to access server related
46:04
resources directly this means we can make direct database calls instead of needing to create an API and then fetch
46:12
that API once again and if you're still not convinced you can always go for client side fetching how just add Ed
46:19
client to the top bring back the use effects the use States and you're all set nextjs will allow you to do whatever
46:26
you think is is best and let's be honest this is how we all used to use next GS
46:31
when we first transitioned over from react it only feels natural but it is the wrong way to use nextjs and that's
46:39
what made me create the whole ultimate nextjs course in the first place to teach NEX GS the right way but now take
46:46
a moment to test both client side and server side rendering you'll notice the
46:51
differences I mentioned such as seeing the blank page initially with client side rendering or if you inspect it
46:57
source and see that nothing is there or client side not functioning at all if you disable JavaScript in contrast
47:04
serers side fetching will still display the results even if JavaScript is turned off in the browser but now that we know
47:12
that serers side fetching is preferable let's explore different server side
47:17
strategies that allow you to manage how and when you render your content on the
47:22
server side you see this is a crucial part of nextjs and I know that some of
47:28
you might be thinking I just want to code already but without understanding these Concepts you'll probably end up
47:35
saying I hate nygs it never works the truth is it does work just not for you
47:42
you just need to write skills to make it happen that's why even on my platform I dedicate an entire section to breaking
47:48
down these strategies before we touch a single line of code and we'll be doing the same thing in this video trust me
47:56
it'll will make your life a whole lot easier the first technique is static
48:01
site generation or SSG a technique where HTML pages are
48:07
generated at build time this means that the content is created when you deploy
48:13
your site not when a user requests it it's extremely fast and can be served
48:19
from a CDN but it's not suitable for websites that need frequently updated
48:24
content by default xgs uses a static rendering strategy your result is cached
48:31
and delivered through a CDN Network ideally you want to use this strategy for blogs documentation sites or
48:38
marketing pages but in many cases you'll have to go for incremental static
48:44
regeneration or ISR for short it's an extension of SSG that allows you to
48:51
update static content after you've built your site this means that it'll create static p PES and build time behaving
48:59
like SSG and then after some time has passed it'll create or update those
49:04
static Pages once again after you've deployed your site basically it combines
49:10
the benefits of static generation with the ability to refresh or update content
49:16
if you want to use ISR as a strategy you can do this in two ways the first one is
49:22
time based revalidation you can revalidate your entire page after some
49:27
time by simply exporting a variable called revalidate and set it equal to
49:32
the number of seconds of when you want to revalidate isn't that crazy expert cons revalidate and then that changes
49:39
your rendering strategy super simple and the second way is to revalidate the request after some time and that would
49:47
look something like this you have a Fetch and then you provide the options object with next
49:53
revalidate the difference between these two is that the first approach uses the revalidate export which is a route
50:00
segment config it sets the revalidation time for the entire page to 3600 seconds or 1
50:08
hour this means that the entire page including all data fetches within it
50:13
will be revalidated every hour while the second approach uses the next revalidate
50:19
option in the fetch function it sets the revalidation time specifically for this
50:24
data fetch to 1 hour this means that only this particular data fetch will be
50:30
revalidated every 3600 seconds while other parts of the page or
50:36
other data fetches if any are not affected at all and there's also OnDemand validation instead of doing it
50:43
on time you can also revalidate using revalidate path and revalidate tag for
50:50
on demand validation of content I hope that's clear enough that's how you can use ISR are it's perfect for those
50:58
websites whose content changes occasionally but still doesn't need realtime updates the next rendering
51:05
strategy is server side rendering or SSR it generates the HTML for a page on the
51:12
server in response to a user's request this means that the content is
51:18
created dynamically for each user request and not only for each deployment
51:24
it's slower than SSG and puts more load on the server but you'll always have
51:30
up-to-date content this is ideal for highly Dynamic content or pages that
51:35
need real-time data similar to what we did with ISR you can use the same configs for SSR for timebase
51:42
revalidation instead of setting it to some random number of seconds you simply set it to zero telling nextjs to render
51:49
the page every time the user requested and if you only want to do it for specific requests you can use the cash
51:55
no store or or set the revalidate to zero there and same thing happens with the on demand validation like revalidate
52:02
path and revalidate tag you can learn more about them in the documentation but so far everything is super intuitive and
52:11
finally there's the partial pre-rendering PPR it's a new rendering
52:16
model that combines static and dynamic rendering it allows you to render a
52:21
static shell of a page while streaming Dynamic content the key key difference
52:27
with PPR is that it allows for a hybrid approach within a single page unlike
52:32
other strategies that work on a page level here's how PPR works during build
52:38
time nextjs generates a static shell of the pages this shell includes the layout
52:45
and any static parts of the page in the form of components this static shell
52:51
includes placeholders for dynamic content we do it by wrapping Dynamic components in a suspense tag when a user
52:59
requests the page the static shell is served immediately and then the dynamic
53:05
content is streamed in as it becomes available so what does this mean well with PPR you can have static components
53:13
Dynamic components and components that are partially static and partially Dynamic depending on what you need
53:20
you'll actually learn about all of these strategies in action in the application you'll develop today so for now now
53:26
let's keep going we're almost there and ready to start building the app but first I have to tell you a bit about API
53:34
routes enough with front-end stuff optimization caching performance and all
53:39
that it's time for some backend work if you've ever done some backend even creating a simple hello world from
53:46
server message requires a fair bit of setup it involves setting up a project
53:52
installing necessary packages like Express for node right writing server code setting up Express the port and
53:59
then making that Port listen running it and then deploying it using some paid or free service so you can finally use it
54:06
on the front end it might not seem like a big deal when you're just reading or looking at
54:11
the code but things quickly start getting complicated when you have to write various routes middle Wares and so
54:18
on but in the newest version of next GS it's super simple much closer to what we
54:23
did on the front end you just create a special file within a folder for the specific route and you're all set
54:29
there's no need to set up manage or monitor an active server separately if you want to show the same message hello
54:36
world from backend in nextjs you simply need to create a folder with any name
54:42
and then create a special file named route. DS inside it from there you can
54:48
immediately begin writing server code export async function get return
54:53
response. Json message hello world from backend that's all there is to it your
55:01
folder name serves as your API route name with your business logic neatly
55:06
encapsulated within this special route file if you now go to the browser modify the URL and add hello world to it you'll
55:14
see Hello World from backend as a response but how can you create other API endpoints like post patch delete and
55:21
more well for that let's create a book endpoint with a local array as a
55:26
database a common practice when creating route handlers is to create a folder
55:32
called API and write all the routes inside it so create this API folder in
55:37
the app directory and add a database file for storing some dummy books then
55:43
you can create two routes get and post in app API books route.
55:50
TSX these are nested routes similar to what you explored previously in the routing part the UI for the delete and
55:58
put you'll have to create Dynamic route handlers and you already know how to do that app API books and then Dynamic
56:07
square brackets ID SL routts and inside of it you can export
56:13
async function put for the update request and then export async function
56:18
delete for the delete request and then you can add the logic so far this feels
56:24
good similar to what we did with UI routes but this time for writing server
56:29
code and creating apis so let's test them one by one to see if they work or not and there you go
56:37
everything works perfectly this is how route handlers or apis work in nextjs
56:43
it's super simple and straightforward and the creation of apis in nextjs was
56:48
nice but how can you use them on the UI well it's a simple fetch just create a
56:54
books route real quick and call the get API route to fetch the content const
56:59
responed await fetch Local Host 3000 API books you get them from the response
57:05
send them to the state and render them if you visit the books route you'll see all of your books as easy as it could be
57:14
thanks to the serverless architecture of NEX GS and react 19 react server
57:19
components and there's one final thing I want to teach you before you're ready to start creating your next GS application
57:26
and that is search engine optimization specifically how we use metadata in
57:32
nextjs to improve our SEO and when I mention metadata I'm referring to the
57:38
look and feel of our website when we share it with others on messenging platforms or posted on social media
57:45
platforms or on internet in general like for example in search engines in today's
57:50
world we need to ensure that our content is sharable so there are two ways in which we can manage met data in our
57:56
nextg application the first one is config based all you have to do is
58:02
create a JavaScript object into the layout or any kind of page file and Export it nextjs will automatically
58:09
detect it and turn it into relevant meta tags for those routes something like
58:14
export const metadata is equal to and then in there you can provide all sorts
58:20
of different SEO properties such as title description thumbnail and more we
58:25
already already have a config file in our app layout. DSX however if you
58:30
navigate over to the homepage and add an additional metadata something like home
58:35
next GS then that one will be taken into account because it's higher on the priority list and it'll override the
58:43
default specified in the global layout this allows you to either define unique
58:48
metadata for each route or rely on the metadata from the root layout it's
58:54
entirely up to you but everything with this discussed so far is just static metadata means that it's not going to
59:00
change home is always going to be home but there also going to be cases in which you want to create Dynamic
59:06
metadata based on some kind of content on the page such as a Blog title for
59:11
example let me show you how I implemented this strategy on JS mastery. proo for the resources page on the main
59:19
Resource page you'll see different titles and descriptions and if you click on one of the resources you'll see a
59:25
change in the title and description as well same thing happens for the other resources each has its own title
59:32
description and image which helps web crawlers index these pages and makes them much more sharable on social media
59:39
but how can we achieve this in xgs it's super simple the only thing you have to do is export a new async
59:47
function called generate metadata which gets access to params pams being the
59:53
same pams that we had before from dynamic routes you can extract the ID or
59:58
the name or anything else based on that ID you can get full resource details or
1:00:05
user profile details whatever it is then you can use those details to formulate
1:00:11
SEO title descriptions thumbnails and more and you can simply return a dynamic
1:00:17
object of all of these properties that's it as simple as that are you with me so
1:00:22
far good and the other way in which we can set metadata in nextjs is file based
1:00:29
metadata as the name suggests you can put files like a robot sitemap favicon
1:00:35
open graph images or other site icons directly inside the app folder and
1:00:40
nextjs will automatically detect and generate corresponding meta tags for
1:00:46
example you can have an app and then a favicon and then an icon and then an open graph image Twitter image all of
1:00:53
these properties will get added to your metatags it's just about adding the files with the right names they have to
1:01:00
be proper names directly inside the app folder it'll work out the same as the
1:01:05
config based approach you can find a full list of all files that can be created to Define metadata here but for
1:01:13
the time being I still prefer creating it by exporting the config file from layouts or individual pages and it's
1:01:20
worth noting that file-based metadata has a higher priority and will override
1:01:26
any config based metadata so if you set it in a file it'll be used instead of the ones that you set in the
1:01:32
configuration so now you know how to make your apps sharable SEO optimized
1:01:38
and search engine cable with that in mind I think you're ready first there
1:01:43
was a lot of theory and then there was more Theory disguised in this practical part but now you're ready to dive into
1:01:51
code you're ready to Dive Right In and build and deploy your nextjs app with
1:01:57
all of these optimizations performance updates and new features baked right
1:02:02
into it application you will develop and deploy along with the specific nextjs
Demo of the App
1:02:07
features you'll use on the homepage you'll find a list of startups fetch directly from sanity and the great part
1:02:15
is that whenever someone anywhere in the world submits a new startup it'll instantly appear for all the other users
1:02:22
here without needing to reload the page you can also search for any startup by title Creator name or category in real
1:02:29
time in this case let's go with category of Health you just click it right here and you can see that search works
1:02:36
instantly for this we're using next gs's latest next form feature which
1:02:41
automatically manages the URL State and allows form submissions via keyboard events with minimal code required now if
1:02:49
you click on any one of these startups you can view its details including the title date when it was published a
1:02:55
description thumbnail more information about the author and then finally the pitch details in this case we just use
1:03:02
regular text for the details but if we go to another post you can see that it supports full markdown capabilities and
1:03:10
at the bottom we have some other recommended posts but maybe the most important part of this entire pitch
1:03:16
Details page besides this great looking image of course is the number of times that this post has been viewed and you
1:03:22
can see that right here at the bottom right even though it might feel like a small feature it's actually quite
1:03:28
significant here you'll be using NEX gs's latest rendering strategy known as
1:03:34
PPR partial pre-rendering with this approach everything except the view counter is kept as static content for 60
1:03:42
seconds using incremental static regeneration while the views counter is handled with server side
1:03:48
rendering this means that whenever a user requests a page most of the details are served from the CDN cache but the
1:03:55
views are recalculated with each request and aren't cached that is what PPR is
1:04:01
all about giving you control over which parts of the page remain static and which are regenerated dynamically we're
1:04:07
also applying the same strategy on the user profile page where the user details are cached but the content such as
1:04:14
submitted startups is always generated fresh with each request this ensures that the latest
1:04:21
data is displayed without caching using the PPR approach to to submit a startup
1:04:26
you'll need to create an account first by signing up with GitHub using social authentication I already authenticated
1:04:33
before so you'd log me right in you'll do this using the latest version of next off and once you signed in your account
1:04:39
will be stored in sanity and you'll be able to go over to the create startup page here we're utilizing react 19's
1:04:46
highly anticipated use action State hook along with nextjs server actions all
1:04:53
Fields right here including the image URL are val validated using Zod ensuring that no validation is kept now I'll
1:05:00
split my screen in half keeping one side on the homepage and another one on the startup creation page I've entered some
1:05:07
details and I'll go ahead and submit my pitch the second I click this it's submitting the success I got rated and
1:05:15
check this out immediately without a Reload this startup appeared right here
1:05:20
on the homepage that's how real time updates work and I'll teach you how to do it isn't all this amazing pretty cool
1:05:27
app that purposefully features so many of the new NEX GS features so now let's
1:05:32
build it together and let's explore everything that next GS has to offer to develop this great application we'll use
1:05:39
react but not just playing old react will power it up with nextjs
1:05:45
specifically with the latest and greatest of what nextjs has to offer even though nextjs comes with many
1:05:52
built-in optimizations as you might know if you watch the crash course I'll also teach you how to use it to the fullest
1:05:58
potential by handling things that are not coming out of the box such as implementing Dynamic HTML streaming
1:06:05
react server components many different ways of data fetching depending on the use case client and server rendering and
1:06:12
much more for styling we'll of course use stnd CSS a utility first CSS
1:06:17
framework that allows you to style your applications very quickly but still gives you the possibility to keep your
1:06:23
design completely custom and on top of tailin CSS we'll also use shaten a
1:06:29
component library that provides you with the necessary components that you can simply copy and paste into your apps
1:06:36
finally I know you've been waiting for this day you'll Implement o from scratch
1:06:42
using next off specifically we'll do a GitHub integration and on top of all of
1:06:47
that I'll teach you how to manage the content of your application using sanity
1:06:53
so with that in mind let's go ahead and and set up our new nextjs project to get
Setup new project
1:06:58
started create a new empty folder on your desktop name it something like YC
1:07:03
directory and then open it up within your code editor within it open up your terminal run MPX
1:07:11
create-- apppp at latest. SL to create it in the current repository it's going
1:07:17
to ask you a couple of questions and we just want to press enter for all of them since we'll be using the default
1:07:23
recommended options of course we would like to use typescript to make her project type safe we would like to use
1:07:29
eslint to make sure that our codebase is clean Tailwind CSS sign us up no need to
1:07:34
put everything inside of the source directory just putting it within the app is fine we will be using the app router
1:07:41
turbo pack for smoother development environment no need to customize the default import Alias and that's it the
1:07:48
packages are getting installed there we go our project has been initialized but
1:07:53
before we run it there's one more thing we have to do head over to your package.json and here you can see that
1:08:00
we're using the latest versions of react as well as nextjs but we also have to
1:08:06
make sure that all the other packages and dependencies that we use such as next o also use those latest versions
1:08:13
and not go back to using react 18 for example for that reason we have to add two additional properties to our
1:08:20
package.json let's add it right below the scripts one
1:08:25
one is to set a specific version of your package manager in this case I'm using mpm so I'll set it to mpm at
1:08:34
10.5.2 and then also set the overrides react dollar sign react and react Dom
1:08:39
dollar sign react Dom this will ensure that the latest versions of react are being used across all the packages in
1:08:47
your project and after you do this make sure to not delete node modules and then reinstall them because that might break
1:08:54
some things if you were thinking of doing that then just copy the exact versions of react and react Dom and put
1:09:00
them right here in the overrides in that case it'll work great now that we have done this we can simply run mpm runev to
1:09:07
see the server in action so let's open up the terminal and say mpm runev and
1:09:13
there we go our application is now live on Local Host 3000 which means that we are ready to start developing
Authentication with NextAuth
1:09:21
it this time we'll start straight with Authentication which we'll be implementing using OJs or also known as
1:09:29
next o so let's head over to installation and we'll choose nextjs of course first things first we have to run
1:09:36
the installation command so let's copy it and I've opened up a new terminal inside of which we can run those
1:09:42
installation commands so let's install it there we go that was super simple next we'll have to set up the
1:09:48
environment by setting up our off secret so let's copy this command and run MPX
1:09:54
off Secret press y to proceed and this just created a newv local with your odd
1:10:00
secret next we'll have to implement our configuration I'll Zoom this in so you can see it a bit better but you can also
1:10:06
follow along with your own docs the goal of these videos is for me to teach you how to replicate what I'm working not
1:10:13
just follow along so sometimes it's totally okay to pause and try to implement things on your own next we
1:10:19
have to create the ajs config file and object this is where you can control the behavior of the library and specify
1:10:26
custom authentication logic adapters and more create an off THS file in the
1:10:32
project here we can pass all the custom authentication options so let's create
1:10:37
it in the root of your app and copy this config now there directly in the root of your application create a new file
1:10:44
called O.S and paste what you just copied import next o from next o and here we're
1:10:52
exporting a next o object with the complete configuration next we'll have
1:10:57
to add a route Handler under app API o and then we'll have to make this a new
1:11:03
Dynamic rout so let's do just that I'll create a new folder within the app
1:11:08
folder and I'll call it API within the API folder I'll create a
1:11:14
new folder called off and within the off folder I'll create another folder which
1:11:19
is going to be a dynamic one so we'll use square brackets dot dot dot next off
1:11:26
and then I'll close it like this and within it we'll create a new route. TS
1:11:32
file within the route you can copy and paste this code import handlers from at slof and then we export those handlers
1:11:39
the third step is an optional step to add the middleware in this case we'll skip it and next we have to set up the
1:11:45
authentication methods the basic setup is complete but now you can choose the providers which you want to allow your
1:11:52
users to authenticate with so let's head over to authentication and go to ooth here you can jump to one of the
1:12:00
most popular providers for authentication we typically do Google but now I'll do GitHub on this
1:12:06
documentation page you just get a call back URL that we need to call but in this case we need to set it up from
1:12:12
scratch so let's go over to connections providers and then here search for
1:12:17
GitHub there we go and here you'll get all the information how we can create a new GitHub oov app which we need for
1:12:24
this setup so head over to this documentation page and here you get the steps needed to create a GitHub OA app
1:12:31
you have to go to settings developer settings allo apps and then create a new allo app and then add the authorization
1:12:39
callback URL so let's do all of that together head over to github.com go to your
1:12:46
profile go to settings head over to developer settings right at the bottom
1:12:51
left and then don't create a new GitHub app rather head over to oov apps and
1:12:57
then create a new oov app enter the application name such as YC directory
1:13:04
and you'll have to enter the homepage URL for the time being we don't really have a URL yet because it'll be rendered
1:13:10
on Local Host so let's just say Local Host 3000 right here we can switch it later
1:13:18
on once we deploy our application application description well this will be a directory for the new era of
1:13:26
startups I like that and authorization call back URL to know what we need to
1:13:31
put there we can refer to next odds documentation so let's simply copy this and then paste it right here in this
1:13:37
case we'll use Local Host 3000 as the URL and click register well
1:13:45
yeah this is the thing now it's asking us to have a real homepage URL which starts with HTTP or
1:13:51
https so if you just add HTTP col SL slash and press create it'll work great
1:13:59
and now here we got a client ID and we can generate a new client secret so
1:14:04
let's copy the client ID and add it to our env. loal We'll add it as o uncore
1:14:11
GitHub ID and set it equal to this string similarly we can generate a new
1:14:17
client secret for that you'll have to confirm access and once it's generated copy it
1:14:24
as you won't be able to see it again once you do that you can say o GitHub secret and set it right here if
1:14:33
you want to you can also upload your apps logo and that's the perfect time to refer to the complete figma design for
1:14:40
this project the link is down in the description just enter your email and you can get it immediately once you're
1:14:45
there you can explore the entire design and you can get this logo simply double click it and then export it right here
1:14:53
once you export it you can upload it here I'll use just YC perfect let's update our application
1:15:02
and we'll revisit this page at the end of this video to put our new deployed URL right here but for the time being we
1:15:08
can go back to the next odd setup and we can copy the configuration the only thing this is doing is updating our
1:15:15
existing aths file where now we are adding a GitHub provider right within it
1:15:21
so how do we make it work well let's go back to our homepage let's remove everything we have from this home right
1:15:27
now I'll keep just a single react fragment right here for now completely empty we can simply say home now we can
1:15:35
improve our file and folder structure currently our homepage is right here but I actually want to organize this a bit
1:15:42
and create a new route Group which is going to be called root so these are all
1:15:47
our homepages I'll move this page over to this rout and I'll also create a new
1:15:53
layout file right here layout. TSX that means that what we apply to this layout
1:16:00
will only be applied to the pages within this route group so let's say export
1:16:05
default function layout it accepts children as a prop and we need to define
1:16:11
the type of that children and we'll set it to read only because we're not going to modify it and then you can say
1:16:17
children is of a type react. react node finally we can return a new main tag
1:16:24
with a a class name equal to font DW work- sense so this is a special font
1:16:30
we'll apply later on then as you know within every layout we need to render the children but what this specific
1:16:37
layout will do is it'll render a Navar right here on top of it so let's create
1:16:43
a new components folder and within it let's create a new file called navbar
1:16:49
TSX let's run rafc within it to create a react Arrow function component and if
1:16:56
this didn't work for you that must mean that you don't have the necessary plugin the plugin I'm using is called modern
1:17:03
react Snippets so just install it and it should work once you do that we can go back to the layout and we can autoimport
1:17:10
this SV bar as a self-closing component right here so now we have the nav bar we have the layout and we have the homepage
1:17:17
let's actually turn this home into an H1 that will say home and we can give it a class name equal to text Dash to excel
1:17:25
to make it a bit larger now if you go back to Local Host and you reload you should be able to see the Navar at the
1:17:32
top and then home right here below it that's perfect because right within the nav bar we'll Implement our next off
1:17:39
let's style it just a bit by giving it a class name equal to padding xl5 to give
1:17:44
it a bit of spacing on left and right padding Y3 to give it some space on top and bottom BG white shadow DSM for a
1:17:53
small shadow and font DW work- sense and that's going to be within an HTML 5
1:17:59
semantic header tag within which we can render a nav tag with a class name equal
1:18:06
to flex justify Dash between items Das
1:18:11
Center within it we can render a nextjs link tag with an href pointing to forward slash meaning it's going to go
1:18:18
just to the homepage and within here we can show our logo that's going to be a nextjs image tag with a source equal to/
1:18:27
logo.png an Al tag of logo a width of about 144
1:18:32
pixels and a height of about 30 pixels if we save this currently the image will
1:18:38
not load that's because we don't yet have it in our public folder so let's remove all of the files from the public
1:18:44
folder that we have there right now and let's get the logo directly from
1:18:51
figma you can export it as you already know you can drag and drop it from your downloads and then you can just rename
1:18:58
it to logo.png if you do that there we go now we know that you're starting to build
1:19:04
the YC directory moving forward we're going to go below the link and we'll render another div with a class name
1:19:12
equal to flex items Das Center and a gap of
1:19:18
five within here we only want to render things if our user is logged in so so
1:19:25
how can we know whether a user is logged in well we can look into a user session
1:19:30
that is coming directly from next off so let's say con session is equal to await
1:19:38
o which we have to import from at SL off and since we used a weight here we need
1:19:44
to turn this into an async function and we can do that because this is a server rendered component how cool is that you
1:19:51
would never be able to do this in client components so so now that we have the session we can do a quick check and say
1:19:58
if session exists and if session has a user then render this additional
1:20:05
information about that user or give them the possibility to perform some actions such as a link that will have a
1:20:13
span within it and it'll say something like create it'll also have an hre of
1:20:19
slst startup slre pointing the user to that create page and below the link link
1:20:25
will have a button with an onclick property equal to sign out and this is
1:20:32
something we have to import from o so let's get O Let's Get sign out and let's
1:20:37
get sign in as well so in this case we want to Simply sign out within the
1:20:42
button we can create a span and say log out finally we're also going to have one
1:20:48
more link which will point to the user's profile so let's say href is equal to
1:20:54
Dynamic URL of sluser SL sessionm
1:21:00
mark. so we want to go to the ID of that specific user for the time moment within
1:21:06
it we can simply render a span which will render a session question mark. user question mark. name and since I
1:21:14
opened up a tary operator right here we also need to provide a second half of that operation what happens if we don't
1:21:21
already have a user and in that case I'll create a button with an onclick equal to sign in
1:21:31
and when you call sign in you also need to pass the provider in this case it'll be GitHub this button will have a span
1:21:39
which will say login if I save this and collapse her editor so we can see the browser at the
1:21:45
same time you should be able to see the button on the right side but it's barely noticeable because the color of the font
1:21:51
is not dark so on this D let's simply give it a text- black property and there
1:21:58
we go we can see a login button because our session has not yet been established
1:22:04
and before we go ahead and click it you can see that our on clicks are complaining both this one and this one
1:22:10
here if you hover or sign in you can see that it's saying missing a weit for an
1:22:16
async function call yes sign in is asynchronous meaning we have to add a
1:22:22
weight in front of it so if I do that you can see that that's not really a valid syntax that means
1:22:29
that we have to turn this into a server action let me show you how I'll create a
1:22:35
new callback function right here and then wrap this call within it makes
1:22:41
sense so far right then since we're using a weight I'll add a sync right here and I'll add a use server directed
1:22:49
right here which will ensure that this gets called on the server but but if you
1:22:55
click login no luck we still get an error and this one is a bit weird but
1:23:01
essentially what it's saying is hey you cannot use a server action within a
1:23:07
component that is maybe the best example of a client component a button with an
1:23:13
onclick so let me show you what you have to do instead actually you'll be using the
1:23:19
latest react 19 server actions with a new form feature
1:23:25
you can pass a server action to a form and automatically submit the form to the
1:23:30
server this is quite new so bear with me essentially you define an HTML 5 form
1:23:37
give it an action which can be a server action and it'll execute on the server
1:23:42
and I also have an example from nextjs docs saying that react extends the HTML form and you can provide a server action
1:23:50
with the action prop so let's explore it in action no pun intended and I'll turn this
1:23:57
onclick into an action specifically it is an asynchronous server action trying
1:24:03
to sign us in now within it I can render a button that'll have a type is equal to
1:24:09
submit it'll simply submit the form and we can say something like login right
1:24:15
here now if you press the login button check this out we got redirected to
1:24:21
GitHub authentication but we get a bit of a warning saying that the redirect URI is not associated with this
1:24:27
application pointing to a slight misconfiguration believe it or not the fix is in one single letter sometimes
1:24:36
issues like these are the worst just go back to your oo setup scroll down and
1:24:42
then go to the authorization callback URL I copy this over from next off
1:24:47
documentation and here they have a live deployed URL under https security but
1:24:54
Local Host by default is HTTP security so let's put it like this go back to our
1:25:01
app and click login and there we go we can authorize YC directory so let's
1:25:08
click authorize and for the second time we get an error that you now know how to
1:25:13
fix it's referring to turning this client component props such as onclick
1:25:19
into an actual form action so let's do just that first I would recommend that
1:25:24
you try it out on your own and then we can do it together so if you want to give it a shot pause the video if not
1:25:31
let's continue I'll turn this button into a form and I'll turn the onclick
1:25:37
it's called a client side prop which is interesting onclick and I'll turn the onclick which is specifically called a
1:25:45
client component prop interesting name if you think about it into an action
1:25:51
which is no longer a client component prop in the action I'll turn this into an
1:25:57
asynchronous callback function and I'll Define you server here
1:26:02
to the note that it's being used on the server then I'll say await sign out and
1:26:09
I'll even pass an additional option of redirect to equal to forward slash so
1:26:15
after log out we redirect back to homepage if I save this you can see
1:26:22
we're now good you can see my full name right here at top right and also the create and log out buttons this means
1:26:29
that next o is properly reading the user session great for the time being I also
1:26:35
have to turn this span into a button with a type equal to submit so now if we press log out we are
1:26:43
out and if we press log in we're back in perfect I hope that made sense you have
1:26:49
officially learned how to set up authentication from scratch using next off as well as some goas with using
1:26:56
server actions within client component props and how to fix those issues within
1:27:02
new react 19 forms and I even prepared a quick diagram for you so we can do a
1:27:08
quick recap as a user you first click that sign in with GitHub button at the top of course I'm referring to our login
1:27:15
button once we click it our nextjs app will initiate authentication over to
1:27:20
next off which will then redirect to GitHub oo GitHub oath will then request
1:27:26
our user for authorization that looks something like this I click it and then if we haven't
1:27:32
been logged in previously it would redirect us to that GitHub page but in this case it redirected us and we
1:27:39
directly granted permissions now it's time for GitHub and next o to communicate GitHub sent over the
1:27:45
authorization code to next O next o exchanged that code for the access token
1:27:50
GitHub returned that access token and then next o requested user data GitHub
1:27:56
returned it and that was enough for us to create a session once the session was created we were redirected to the
1:28:03
homepage and this is how the entire o flow works from scratch using next next
1:28:09
o and a thirdparty oop provider in this case GitHub but it's more or less the
1:28:14
same for Google Facebook or any other if you'd like me to do more of these graphs and deeper explanations in future videos
1:28:21
let me know in the comments down below and I'll make sure to include it every website also has its unique
Theming and Fonts
1:28:29
theme and if you compare the font family of our links you'll notice that it's
1:28:35
different from the logo and it'll become even more apparent once we continue building at our homepage here we have a
1:28:42
really bold font so let's ensure that our entire app actually uses it for that we'll have to set up our tailan config
1:28:49
so if you go to the description down below click the GitHub repo and then go to Snippets right here you'll see our
1:28:56
Tailwind config and this time I'll make sure to explain it thoroughly so let's
1:29:02
copy it let's go to our file explorer open up our tailwind config.txt
1:29:11
and CSS works you extend the theme to provide some specific variables that you
1:29:18
can use later on in the code so for example when you're saying EXs Max with
1:29:23
something then you're referring to 475 pixels to apply this property or with colors it's
1:29:31
even simpler instead of every time saying text Dash and then providing a special
1:29:38
property like this ff8 F0 and then closing it every time you can just
1:29:44
simply say text- 100 basically you're providing
1:29:49
your own custom colors which you can more easily reuse across the entire project and where are you going to get
1:29:56
these colors from well if you go to the figma design and you show the UI you can
1:30:02
select a specific element and then right here under properties you can see the padding the width and everything and for
1:30:10
elements that have a background or a font you can also see background colors so if you go right here to our hero
1:30:17
section you can see E2 b69 and right here that is the default color of our
1:30:23
application so what we're going to do is just take these colors and put them right here with proper naming different
1:30:29
versions of blacks the primary secondary the white and then we're also adding a
1:30:35
font family of font work SS I hope that makes sense and if you'd like me to do a
1:30:40
detailed video on setting up a Tailwind config just let me know with that in mind we get one more error in our
1:30:46
application saying that we haven't installed Tailwind CSS animate it is a great plugin for Tailwind CSS allowing
1:30:54
to further animate your Styles so in this case I'll simply run mpm install tailin CSS animate to add it to our pek
1:31:01
adjacent alongside Tailwind CSS animate we also have Tailwind CSS typography
1:31:07
which will allow us to further play with fonts so just run mpm install at tailin
1:31:12
CSS typography as well if you reload we're good to go now let's go over to
1:31:17
our primary layout it is this one right here directly within the app we'll use
1:31:23
this this one to set up the right fonts you could of course use Google fonts to set this up but it is actually
1:31:30
preferable to have them hosted locally so I provided all the fonts and assets
1:31:35
for this project right here within the assets directory so just open it up press download open up the assets and
1:31:42
unzip them and then simply drag and drop them to the root of your directory in the assets we currently have a new
1:31:49
favicon so let's simply pull it into the app which is going to place the old one
1:31:55
there we go this is the new one kind of like a light bulb idea for our startup next in the assets folder we also have
1:32:02
the fonts so let's delete the current font folder and drag and drop the new one into the app and finally we have the
1:32:09
public which is outside of the app this one right here below the node modules so delete it and drag and drop the one from
1:32:17
the assets outside of the assets into the root not into the app Remember the
1:32:23
public folder has to be outside of the app now for the time being this will break our application because we have
1:32:29
added new fonts so let's delete the existing ones and say const work sense which is
1:32:36
the font family is equal to local font pass an options object with a source
1:32:42
equal to and now we have to point to different font styles of that font here we're using the new nextjs functionality
1:32:49
where we can define local fonts directly within our application each one will have a path of that SL fonts slor sense
1:33:00
dblack dttf so we're simply pointing to the path of that specific font this one
1:33:06
is black so it'll have a weight of 900 and a style equal to normal now we'll
1:33:14
have to duplicate this a few times so let's do that 1 2 3 4 5 6 7 maybe even
1:33:21
because we'll want to have all different weights of that font so we'll have something like 800 which is going to be
1:33:28
work sense-- extra bold then we're going to have 700 which is going to be bold
1:33:37
then we'll have something like 600 which is going to be semi bold then we have
1:33:42
500 which is going to be medium we have 400 which is regular then we have 200
1:33:50
which is thin and I'll duplicate it one final time this time it'll be extra light and
1:34:00
it'll be 100 finally we need to provide a variable name right here below this
1:34:06
array by saying variable to Define which class will set this font up it'll be
1:34:12
font dwor sense great and you can see that it's still complaining here because
1:34:17
we're using the previous Sans font instead of this right here we'll render
1:34:23
work sense. variable there we
1:34:29
go and you can see our font family immediately changed for all elements within our Navar another thing we can do
1:34:36
in this layout as you've learned at the start of this course is that you can change the title in this case let's call
1:34:42
it YC directory and we can also provide some kind of a description like pitch vote
1:34:51
and grow if I save this you can see that our favicon as well as the title have changed immediately
1:34:58
that's great you've just set up the primary layout of our application to allow for Tailwind CSS theming as well
1:35:05
as you have learned how to use local fonts allowing you not to depend on external services like Google fonts you
1:35:12
have added your own fonts within your application which will always be here no matter what great job now we can move to
1:35:20
an exciting part that will turn this black screen into something much more engaging so let's focus on the hero
1:35:27
section next to get started with our homepage
Hero Section
1:35:32
you can go into the root route group and dive into the page. DSX this is where
1:35:39
our home is now remember when we were talking about theming not that long ago
1:35:44
well in this case we'll extend our theming even further if you take a look
1:35:50
at the design you'll notice that there are some shared styles that we can read use such as the heading right here you
1:35:56
can notice that this picture startup connect with entrepreneurs is also shared here and here same thing for this
1:36:04
yellow thing at the top the styles for this description so instead of declaring the Styles every single time we can
1:36:11
create a utility class called heading or subheading and then we can reuse it
1:36:17
further let me show you how to do that I'll head over to global. CSS and here
1:36:23
we import in Tailwind which is great but what Tailwind CSS also allows you to do
1:36:28
is to add something known as ADD layer and then utilities these are called
1:36:34
utility classes and if you say something like do heading right here you can use a
1:36:40
property of apply meaning once you use this class which tailin CSS classes will
1:36:46
be applied well let's think about it for example you'll apply a property of
1:36:52
uppercase right here because all of the text is uppercased so let's do
1:36:57
uppercase Also let's do BG black because it'll have a black background padding X
1:37:03
of six to provide some spacing on the left and right and padding y of three to provide spacing on top and bottom
1:37:09
usually it was easier to get these styles from the figma design but nowadays figma wants you to pay for the
1:37:15
dev mode if you had it you would be able to extract some more additional CSS properties from it but don't think that
1:37:21
you would immediately get everything and then paste it here um typically many things in the design are hardcoded like for example this
1:37:28
padding values you're not going to put these exact values because we have to ensure it works across all devices so
1:37:36
it's good to sometimes try to figure it out on your own and then convert those styles from figma to here we'll change
1:37:43
the font to font work sense we'll change the font to extra bold we'll make the
1:37:49
text white because we have a dark background here let's also set on small devices the text size to 54 pixels on
1:37:57
small devices we can also set the leading which is the space in between the characters to 64 pixels typically
1:38:04
the text can be set to 36 pixels oh it's jumping out of my screen right here because it's so long there we go the
1:38:12
text will be set to 36 pixels typically the leading will be set to 46 pixels if
1:38:18
we're on regular devices Max W will be set to 5 XL
1:38:23
text will be centered and margin y will be set to five that's a lot of classes
1:38:29
for one single heading but it's much better to have them here in the utilities rather than to have all of
1:38:37
those things copied and then we can paste them right here for this heading I
1:38:43
mean just look at this right it will be too much and if it go back sure we have
1:38:48
a nice looking heading but even the fact that here we have all the Styles is not a problem that's how Tailwind CSS is
1:38:55
designed what is a problem is that back right here on our create we'll have to
1:39:01
copy and paste all of those Styles and then imagine if one thing changes not good right same thing here so for that
1:39:10
reason we create a utility class give it a name and now when you want to reuse
1:39:15
that same thing you just say heading okay so now if we go back before it
1:39:21
works we actually have to import the font right here in the global and we do get a slight error here but it just
1:39:28
looks like I forgot it to add a dash right here in the font Works hands so if I add it we're good you can see the home
1:39:35
right here and our code right here is looking incredibly clean now you can head to the read me file of this video
1:39:42
and copy the global. CSS from there and override everything we have here if you
1:39:48
do that you'll notice that we're adding a few more of these utility classes to make the styling of our app a bit easier
1:39:54
but at any point in time you can just refer to the global. CSS and see exactly
1:40:00
what CSS are we applying as you can see the heading we just wrote is right here among the tag
1:40:07
the pin container the subheading and more I hope this makes sense now alongside improving our theming with the
1:40:13
global. CSS to make our Tailwind CSS classes more reusable it's also the
1:40:18
perfect time to install shaten to be able to reuse some of the components
1:40:24
that will help us make the UI of our application so go to ui. shen.com and
1:40:30
search for the CLI they just released it it is completely new and it's something
1:40:35
I want to teach you in this course as well the Shian CLI provides an init
1:40:41
command allowing you to configure and add dependencies for your project so let's do it together we can copy this
1:40:47
command and add it to our terminal MPX Shad CN add latest in
1:40:54
it it's going to ask us a couple of questions you can choose the style of New York in this case let's go with
1:41:00
slate and for CSS variables you can choose either yes or no and this will update our tailin config and our Global
1:41:07
CSS so let's check them out by going to globals looking at the globals it
1:41:13
remains very similar but they have modified the one that we have copied so
1:41:18
it's better to stay on the safe side and copy and paste it one more time from the read me that I provided to you and the
1:41:25
same things goes for the Tailwind config because they modify that as well so if you just override both of
1:41:32
these two new files and go back to Local Host 3000 everything should look great
1:41:37
and we are ready to start coding the header of our application first I'll create a new section it's an HTML 5
1:41:46
Section component and I'll give it a class name equal to
1:41:51
pinkcore container and this will provide this container right here and within it I'll put this
1:41:58
H1 with a property of heading instead of simply saying home it can say something
1:42:05
like pitch your startup then we can add a Break Tag and right below we can say
1:42:11
connect with entrepreneurs okay this is looking great and below this H1 we can
1:42:18
also create a P tag that will have a class name equal to
1:42:24
subheading and exclamation mark Max dw-3 XL we use exclamation mark when we want
1:42:31
to override some other styles previously provided to this element and here we can
1:42:36
say submit ideas vote on
1:42:43
pitches and get noticed in Virtual
1:42:50
competitions there we go sounds exciting if you make your screen a bit
1:42:55
smaller like this or if you make it even larger you'll notice those lines appear
1:43:02
right here and those lines form a very important part of our visual design so where are they coming from well we can
1:43:08
further inspect the pink container class which is right in the globals and here
1:43:14
we apply a pattern class name to it let's explore that pattern further it
1:43:20
is right here below and you can see that we're applying a background image where
1:43:25
it's just a single line being repeated now we can collapse it even further let's go somewhere on the mobile view
1:43:33
right here and this is already looking great and what do we have to do below
1:43:38
our P tag well let's refer to the design it'll be the input field and while we
1:43:44
could create it right here it's better to create a new component for it because while the homepage is server side
1:43:50
rendered the search input will have to have some client functionality right to manage keyboard presses and button
1:43:57
clicks at least that's what we expected so far right so let's see if that's still true with the latest versions of
1:44:03
react and nextjs is there maybe a way to allow us to keep this component as a
1:44:09
server rendered component well let's give that a shot in the next
1:44:14
chapter let's create a new component in the components folder which I'll call
Search Form
1:44:20
search form. TSX run rafc right inside of it to create a
1:44:27
simple functional component and then import it right here below the speed tag that's going to look something like
1:44:33
this search form there we go my IDE Auto imported
1:44:40
for me coming from at slapp SL components SL search form and right here
1:44:47
in the hero section you can see the search form appear right here which means we are ready to dive into it and
1:44:53
start implementing it but let's get to the elephant in the room if this is going to be a form and it surely will
1:44:59
can we still ensure that this is rendered on the server side and not client side up to this point that would
1:45:06
have been impossible but with react 19 forms and the way that nextjs is
1:45:11
extending them even further the new form element now provides prefetching and UI
1:45:17
loading client side navigation on submission and Progressive enhancements in simple terms nextjs now supports a
1:45:24
new form component which is used to automatically update URL search parameters and reduce the boilerplate
1:45:31
code needed to achieve anything the basic usage looks something like this so let's implement it together first I'll
1:45:39
wrap everything in a form coming from nextjs that form will have an action
1:45:44
equal to forward slash and it also has a scroll property which we can set to
1:45:50
false we don't want to scroll anywhere once we sub submitted and we can also give it a class name equal to search
1:45:57
form there we go quite a simple form right within it we will render just a
1:46:02
regular HTML input with a name equal to query the default value equal to an
1:46:08
empty string for now a class name equal to search- input and a
1:46:14
placeholder equal to search startups there we go that looks great
1:46:21
finally if the user has sted something into it then we can provide a button to reset the form so let's create a div
1:46:29
with a class name equal to flex and the gap of two and now we'll want to
1:46:35
implement this button right here but before the button if we type something and search for it we want to also
1:46:40
implement this x right here so we can clear our search so later on we'll have some kind of a query right here so let's
1:46:48
define a fake query and let's say that it's equal to something like test we can
1:46:53
use this query as a default query here as well that's going to look something like this and now if we have an active
1:47:01
query then we want to render some kind of a button that would allow us to reset
1:47:06
it so for now this can be a regular button of a type equal to
1:47:14
reset and on click it'll call the reset function so we can declare it right here
1:47:21
above const reset set is equal to a functional component where we first have
1:47:27
to get access to the form by saying form is equal to document. query selector
1:47:33
we're going to search it by a DOT search- form and since we're in typescript we have to define the type as
1:47:40
HTML form element like this and if a form exists then we're going to Simply
1:47:47
run form. reset which will reset the form on that button click but here's an
1:47:53
issue even though the form itself will be a server side component the button
1:47:58
and the onclick recalling here is still client side so we have to extract it
1:48:03
into a new component that's going to be pretty simple we can create a new component called search form reset.
1:48:13
TSX run rafc within it then we can take this
1:48:21
button and and place it right here and we can also take this reset
1:48:31
form and we can place it right here within this component now going back instead of this
1:48:37
button we can simply render the component that we just created search form reset as a self
1:48:47
closing component and now if we go into that component for the first time in this video
1:48:53
we can use use client directive to turn only this small part of the UI into a
1:48:59
client component but the rest will still be serers side rendered this button will
1:49:04
render a link right within it coming from next link it'll have an HRA of forward slash and a class name equal to
1:49:13
search- BTN and within it we can just render an X character we can also give
1:49:19
it a text- white so we can see that X there we go this is looking good now
1:49:26
right below it we'll render another button and this one will have a type is
1:49:32
equal to submit to submit the form with a class name of search- BTN and it can
1:49:38
say something like s for search of course later on we'll turn this into an actual icon but for now we can give it s
1:49:46
and then text- white so we can know that we can clear the search as well as actually search for something so how
1:49:53
does this work right now we're not really submitting anything or clearing anything because the query is always set
1:50:00
to test but let me show you how easy it is to now make this into a fully
1:50:06
functional URL modifying server rendered form for a moment we'll go back to this
1:50:13
page and there we'll try to access the query from the search parameters so you
1:50:20
know how I taught you that right here through prop on every single nextjs page you have access to search prams we have
1:50:26
to define the type of search prams as well so we can say search params will be equal of a type promise
1:50:35
which then results in a query which is going to be of a type string then we can
1:50:41
extract that query by saying const query is equal to we can wrap it in
1:50:46
parenthesis say await search for rams. query and if we provide await there we
1:50:52
have to turn this function into a sync and now that we have the query we can simply pass it into the search form as a
1:50:59
prop so let's say query is equal to query back in the search form we can now
1:51:04
accept this query as a prop query and it'll be query optional of a type
1:51:13
string and now we can remove this fake query reload our application clear this
1:51:19
test and you can see that now if we search for something like let's say startup for robots have you seen Elon
1:51:26
musk's latest wi robot event that was pretty crazy so let's search for we
1:51:31
robot and press enter check this out it worked immediately even though you might
1:51:37
not know that it's doing something but it's actually modifying the query in the URL saying we robot it's automatically
1:51:44
doing all the pars sync such as adding a Plus instead of a space and it is as easy as that I can now actually clear it
1:51:51
which clears it from the URL and it works perfectly you can continue modifying it and it's just
1:51:59
Flawless it's super simple yet super effective because it is a robust serers
1:52:06
side rendered form which just works it's connected through nextjs search prrams
1:52:12
query and yeah that's it to be honest I'm pretty amazed at how simple it is to implement forms typically it is much
1:52:20
more complicated now to finish it off let's actually add icons here instead of
1:52:25
an S we can use a search icon coming from shaten or if I'm going to be more
1:52:32
precise it's coming from Lucid react which is a dependency of shat xen which provides all sorts of great icons so we
1:52:40
can give it a class name equal to size of five there we go that's much better
1:52:48
and we can do the same thing within the search form right here where we can turn
1:52:53
this into an X icon with a class name which is equal to size all five and
1:52:59
there we go this is now looking great while we're on the topic of shaten we installed it but we haven't really used
1:53:06
it up to this point so let's say that we want to turn these buttons into shat CN buttons how would we do that well head
1:53:14
over to the terminal and run MPX shaten add latest add and then you typee the
1:53:20
name of the component you want to add such as is a button the code for that button will automatically be installed
1:53:27
and added to your codebase that's the benefit of using Shaden over some other
1:53:32
component libraries like material UI because they actually provide you with the full code for this button and it's
1:53:39
completely yours you own it and you can change any properties even though in most cases it's not necessary because
1:53:45
you can style it further by simply providing additional tailin CSS classes now the chat CN created this new
1:53:51
components folder I I notice that we have our own right here in the app and that's actually not a recommended
1:53:56
practice so I'm really glad that this has happened typically in nextjs I would recommend keeping within the app only
1:54:03
the things that nygs specifically needs there such as the routes or API folders
1:54:08
or fonts or favicons or layouts but components are additional pieces of UI
1:54:14
that you can put outside of it so for now let's simply take these three components and move them over to the
1:54:21
components folder that is outside of the app folder and let's delete this components
1:54:29
folder now the shaten components will be within the UI and our own components
1:54:35
will be just within the components folder and we might need to modify some paths to make this work so let's head
1:54:40
over to root and then layout. TSX and let's fix the import for this snap bar
1:54:47
by removing the app folder and same thing in the page remove the app folder from the
1:54:53
import and one more time in the search form remove the app from search form
1:54:59
reset and we are good great in this chapter you learned how you can use the
1:55:06
latest and greatest of react and NEX gs's new form to handle it all on the
1:55:11
server side with less Boiler blate code in the next chapter let's focus on what
1:55:16
comes after the hero section which is a list of all the startups of course to create all we only only need to create
1:55:23
one proper reusable startup card and the rest will simply follow so let's do that
All Startups & Startup Card
1:55:30
next right below the Ping container or the hero section I'll create another
1:55:35
section which will wrap all of our startups or startup cards I'll give it a
1:55:40
class name equal to section uncore container and there I'll render a new P
1:55:47
tag with a class name equal to text D30 D semi Bold And if a query exists then
1:55:55
I'll render something like search results for and let's make this a template string so we can modify it
1:56:02
query pretty simple right search results for the following query but if a query
1:56:08
doesn't exist we'll simply say something along the lines of all
1:56:15
startups great let's save it and you can see all startups but if I search for
1:56:21
some something like programming keyboards you can see search results for programming keyboards pretty
1:56:28
straightforward right now let's go down and let's create a UL an unordered list
1:56:35
with a class name equal to margin top of seven and cardor
1:56:42
grid now this cardor grid is a very interesting utility class so let's
1:56:48
explore it further I typically select it and then press command shift F which
1:56:53
opens up the global search in this IDE and then you can just automatically find it within the globals or you can just
1:57:00
copy it go to Global CSS and search for card grid perfect now this card grid
1:57:08
right here applies a three column grid on medium devices and a two column grid
1:57:13
on regular devices basically for devices of about 768 pixels or about 800 pixels
1:57:20
and larger it'll show three columns and for smaller devices it'll show two and
1:57:26
then a gap of five applies about 20 pixels of space in between the elements
1:57:32
now within there we can map over our posts later on of course we'll fetch
1:57:37
those posts directly from sanity but for the time being I can create a new array
1:57:43
const posts which is equal to an array where we have some objects and let's say that each object contains an underscore
1:57:51
created at property here we can say something like yesterday it can also contain the number of views that the
1:57:58
post has so let's do something like 55 we'll need to have an author of the post
1:58:04
and that author will be an object because it will contain more information such as the ID of the author and that
1:58:10
can be an underscore ID we also need the underscore ID of the post itself so we
1:58:15
can set that to something like one as well of course what would a post be without a description so we can say this
1:58:22
this is a description and we can also render an image so for the time being we need to find a live URL of an image oops
1:58:30
it looks like while I was searching for that live image the recording actually stopped so you can find any image online
1:58:37
put the link here and then after that add the category in this case I typed robots and then also add the title I
1:58:45
said we robots right here once you do that you can head over to the UL that
1:58:50
you created before and we'll need to map over the posts by saying posts question
1:58:55
mark. length is greater than zero and if it is greater then we can map over the
1:59:01
posts where we get each post of a type startup card type and an index and for
1:59:07
each one we can render a new component called startup card so now let's create
1:59:12
this startup card component by going to the components folder and creating a new file called startup card. TSX you know
1:59:21
the run rafc and then go ahead here and just import it automatically and this will
1:59:28
fix the issue you should be able to see one startup card appear because we only have one Post in our fake posts array to
1:59:35
this startup card we can pass the key because we're mapping over things such as index but typically passing an index
1:59:41
as a key is not the best practice so what I would recommend is just getting the post and then underscore ID as the
1:59:48
ID because that's going to be always unique and we can pass the entire post
1:59:54
itself great now we have to go into the startup card to accept those props and
1:59:59
to render them nicely on the screen so let's get access to the post and that is
2:00:05
of a type post is a startup type
2:00:11
card we'll add this one later on once we Implement sanity because one of San's
2:00:16
great features is automatic type checking for the documents in our collections for now this should
2:00:21
shouldn't break our application so let's turn this div into an Li because we are now within an unordered list and each Li
2:00:29
will have a class name equal to Startup dasc card and group there we go that'll
2:00:36
immediately provide some nice borders within it we can create a div with a
2:00:41
class name is equal to flex between within it we can render a P tag that'll
2:00:47
have a class name equal to Startup undor cardor date and within there we can
2:00:53
render the post. created at property or underscore
2:00:59
created at is how we defined it and now we can see that it was created yesterday
2:01:04
what do you say that we immediately turn this into a real date property for now we're just passing yesterday but what if
2:01:11
we used a new date like this which will actually generate a date
2:01:17
JavaScript object which is how we want to do it if you pass a new date we won't be able to render it just like string
2:01:24
we'll have to somehow turn it into a meaningful date string so let's head over to the utils file this is typically
2:01:31
where you want to add functions that do those sorts of things so let's say export function format date which
2:01:39
accepts a date of a type string and then it returns a new date of that date that
2:01:46
we pass in but we call do to Locale date
2:01:51
string in the loc of enus and we can pass the month as the
2:01:58
option to be set to long a day to be numeric and a year to be numeric as well
2:02:06
now if we save that we can wrap this post that created ad into format date
2:02:13
coming from lib utils and just pass it in if you do that now we can see October
2:02:18
133 2024 looking great right below this B tag we can create a div with a class
2:02:26
name equal to flex and a gap of
2:02:31
1.5 within it we can create an i icon which will tell us how many views we
2:02:38
have so let's give it a class name equal to size of six and text- primary and
2:02:44
below it let's render a span that'll render post. views if I save it we can
2:02:51
see 50 5 use we can also give this pan a class name equal to text- 16- medium
2:02:59
going to divs down let's create the second part of the card by giving it a class name equal to flex Dash between
2:03:07
margin top of five and the gap of five within it we can have another div with a
2:03:13
class name of flex D1 and within it we can have a link
2:03:18
element coming from next link this link element will just wrap the
2:03:25
author's name so we can point its href to SL user SL post. author questionmark
2:03:34
doore ID and within it we can render a ptag with a class name equal to text 16
2:03:41
medium and line- cl-1 which will ensure that this username stays on one line and
2:03:49
within it we can render the post. author question mark. name if I save this we should be able to see something here but
2:03:56
there's nothing appearing so if I go here oh I forgot to pass a name to our imaginary author let me use Adrien in
2:04:04
this case there we go I forgot what kind of startup is it oh it's about Elon musk's new humanoid robots Okay looks
2:04:11
like I'll be working with him on that now you can see that we're often repeating post. views post. author post.
2:04:18
author that something well it'll be easier to just destructure the properties coming out of that post you
2:04:25
can do that right here const D structure is equal to post and then you can think
2:04:31
things out of it such asore created at or views or
2:04:37
author and then from the author you can further take out the ID and the name what else do we have we have a post
2:04:45
title we have a category the post ID the post image you get the idea right
2:04:52
we can later on destructure some additional properties if needed oh here's an interesting gotcha with
2:04:57
destructuring if you're destructuring a subproperty from another property and in the same line you're destructuring
2:05:03
another property with the same name you need to rename one of those so let's actually rename the author ID the
2:05:11
underscore ID belonging to the author to author ID like this there we go and now
2:05:19
instead of saying post. created ad you can just say underscore created ad views
2:05:25
here you can just say author ID and right here you can also say name
2:05:33
much simpler right same code but makes more sense below this link we'll use another link and this one will have a
2:05:40
bit of a different href this href will point to SL startup
2:05:47
slost doore ID or just uncore ID and here we can render an
2:05:53
H3 with a class name equal to text- 26- semibold and line- clamp
2:06:02
D1 and it'll actually render just the title right here great oh make sure to
2:06:08
properly close the link there we go we are good and you can already notice that we're using two links one next to
2:06:14
another and we'll use many more links going forward so why are we using different links for the same card well
2:06:20
that's because each one of these these links will lead to another place if you click the person's name well that goes
2:06:27
to the profile page if you click on the title that goes right here to the startup Details page click on the image
2:06:34
project details click on the user Avatar well that's going to go to the profile details you get the idea right and since
2:06:41
we cannot have children link elements meaning one below another such as if we had the entire card wrapped as a link
2:06:48
pointing to project details and then have these children elements pointing to the profile I decided to create more
2:06:55
adjacent links pointing to different routes in our application now let's go below this link and below the div and
2:07:01
let's create another link this one will point to the user
2:07:06
once again so let me copy the atref from the user within it will'll show the Avatar image so let's render a nextjs
2:07:14
image tag with a source of https Colin
2:07:20
SL placehold doco SL600 by 400 and we'll give it an
2:07:28
ALT tag of placeholder with a width of about 48 height of about 48 and since
2:07:36
this is the Avatar image I'll also give it a class name equal to rounded -
2:07:43
full now if you close it and go back you'll see that nextjs will prevent us
2:07:48
from rendering this image because it doesn't know whether we trust this placehold doco Source but we do we just
2:07:56
have to let it know within the next config so let's head over to N.C config.txt
2:08:11
TPS and a host name in this case we'll leave it to as asterisk to allow for
2:08:17
images from all sources there we go now if you reload you should be able to see a placeholder right here but it doesn't
2:08:24
seem to be appearing and if you open up the terminal you can see why the requested resource has type of SVG XML
2:08:32
but dangerously allow SVG is disabled so what you can do is copy this dangerously
2:08:38
allow SVG head over to next config go within images and then add dangerously
2:08:45
allow SVG set to true and then if you reload you should be able to see the image appear right here I think even
2:08:52
setting it to 4848 would make more sense in this case there we go perfect now
2:08:57
later on we will remove this dangerously allow SVG we're only adding it right now for our placeholder images but keep in
2:09:04
mind later on these will be coming from different sources and they won't be in SVG but it's good to know that nextjs is
2:09:11
actually protecting us from things like this now let's go below this link and below the div and let's create
2:09:18
another link this will be the container for startup details so let's copy the href pointing to the startup details and
2:09:27
within it let's create a new P tag with a class name equal to Startup dasc
2:09:34
cardor description or DC for short and we can just render the description in
2:09:40
there make sure that we have these structured it right here at the top looks like we
2:09:46
haven't there we go so now we have this is a description right below this P tag
2:09:52
we can add an image and sure you could use the next gs's image component but in
2:09:58
this case I want to tell you that you don't have to nextjs is very generous with its free plan but if you have a lot
2:10:04
of images you can use up some of those optimization calls but you don't have to
2:10:09
if you just use a regular HTML image pass it some kind of a source like image
2:10:15
an Al tag of placeholder and a class name of startup dasc card under _ IMG
2:10:22
you can show a nice looking image right here as well without spending additional optimizations for now I'll leave it like
2:10:29
this now let's go below this link and let's create the footer of the card by
2:10:34
creating a div with a class name equal to flex Dash between gap of three and a margin top of
2:10:43
five within it we can create a link this link will have an href equal to a
2:10:49
dynamic template string of SL question mark query so it'll actually update the
2:10:55
query based on the category of our post and we have to set it to lower case
2:11:03
within the P tag we can simply say class name of text 16 medium and we can render
2:11:10
our category below this link we can render a Shad CN
2:11:17
button with a class name equal to Startup
2:11:22
up- cardor BTN as child because we have a link
2:11:28
within it so we want to take the form of a link and here we'll point to the
2:11:33
startup details one more time so we can say for SL startup
2:11:39
slore ID and we can say details right here there we go so now we have a nice
2:11:46
looking card with the info about the user pointing to user page and
2:11:51
additional info about the startup pointing to the startup Details page great job so far this is looking amazing
2:12:00
and if I go full screen it is looking even better you have implemented the
2:12:05
navigation bar that allows you to log in or log out we have a search which is
2:12:10
technically working because it actually modifies the URL query based on what you type and finally you have developed a
2:12:17
card UI which will'll reuse for all of our startups but right now with one limitation which
2:12:23
is that we have fake data for it right now we have no way to add new startups
2:12:29
to our application so that's exactly what we'll do next I'll teach you how to use and Implement
Sanity Setup
2:12:37
sanity let me tell you a bit about why we'll be using sanity for this video
2:12:42
sanity is not just a CMS the one that you hand over to your clients and let them manage data in sanity's case you
2:12:49
can truly leverage their apis to build a whole operating system around the
2:12:54
content you'll have the studio that will mirror the content workspace of your application that you can hand over to
2:13:00
your clients so they can manage it as well and that studio is built on top of powerful apis that allow you to
2:13:07
completely customize the way that you create and manage content and finally they actually store it for you don't
2:13:14
think of this as some kind of low code no code tool it's far more than that
2:13:19
some of the biggest companies in the worlds such as Puma Tata digital or even morning Brew use them for managing their
2:13:26
content you can also use them for many different use cases such as marketing media e-commerce and more it's built for
2:13:33
Enterprise so many Fortune 500 companies use it so if you're saying something like oh but our companies actually using
2:13:39
sanity the answer is yes and you can be the one that's going to implement them within their team to make them recognize
2:13:46
the power and speed and efficiency that allows them to manage their content in and the best thing they're very neatly
2:13:53
integrated with NEX GS everything works seamlessly everything from development
2:13:59
to deployment to verell so merge changes instantly go live on the global Edge
2:14:04
Network there's the SSL encryption asset compression cash in validation a lot of things that together sanity and versel
2:14:11
do very well and then the thing that we just have to discuss the pricing sanity's pricing is incredibly generous
2:14:19
if you're just experimenting or even if want to ship smaller projects it is completely free forever you can even add
2:14:26
20 users two data sets and you also get all other features such as unlimited content types locals hosted real-time
2:14:34
content database and more those are the reasons why I chose to use sanity for this project now you can click the
2:14:39
special link down in the description to be able to follow along and see exactly what I'm seeing once you do that click
2:14:46
Start building and create an account enter your project name you you can make it start with something like
2:14:53
JSM and then YC directory or in your case it can be JSM and then you can
2:14:59
enter some other name of the project we'll start from scratch with the CLI so
2:15:04
click create project and there we go now we can initialize our project with the CLI so let's copy this command go back
2:15:12
to the code and paste it right here it'll ask you whether you want to install create sanity the CLI so just
2:15:19
say yes and it's going to ask you to log in so you can choose the login type that you used initially I'll go with
2:15:26
Google and you'll be authenticated once that is done you'll be asked whether you
2:15:31
want to add configuration files for the sanity project in the nextjs folder press y yes do you want to use
2:15:39
typescript that's going to be a big yes as well do you want to use embedded sanity Studio that's going to be a yes
2:15:47
what route do you want to be studio in by default it's for/ Studio so that's okay with us in this case we'll go with
2:15:54
a clean project no template we'll do everything from scratch and would you like to add the project ID and data set
2:16:01
to your env. loal let's say yes and there we go our dependencies are getting installed and soon enough we'll be able
2:16:08
to explore sanity studio in more detail there we go sanity configuration files
2:16:13
have been added successfully and next we'll have to install the latest version of Sanity to use the live API feature
2:16:19
they offer so I'll type mpm install next sanity at Canary and press enter now
2:16:26
let's explore the files that have been created for us if you head over right here you'll see sanity C.S it
2:16:33
automatically added environment variables for us and we also have our config pointing to the base path of the
2:16:39
studio so we should be able to explore this route let's give it a shot back in the browser I'll head over to Local Host
2:16:46
3000 SL studio and press enter but if you visit
2:16:51
this page it'll probably cause an issue and show this error could not parse module this happens because sanity
2:16:57
Studio doesn't work with turbo yet so let's head over to the package.json and under scripts where we have a Dev script
2:17:04
we'll remove the-- turbo for now now if you stop your application from running and rerun it by running mpm runev if you
2:17:12
go back and reload you can now sign into sanity studio with the same email and
2:17:18
password that you used initially and here we are we're successfully authenticated you'll be able to visit
2:17:24
the studio but you won't be able to see anything there as we chose a clean Project without any schemas when setting
2:17:31
up the project so before we can start adding some content right here which is going to be super easy and intuitive we
2:17:37
can go back to the code and explore the new files that have been created for us
2:17:42
let's start with sanity C.S this is a config file so we can use
2:17:48
sanity operations via the sanity C CLI such as the project ID data set and more
2:17:54
below that we have a sanity config this is a simple configuration file used for sanity Studio where we set the base path
2:18:01
and connect it to a specific project ID data set schema and add specific plugins
2:18:07
next we have some more important files and those are going to be within the sanity folder specifically we're going
2:18:13
to look into the sanity lib and then client. TS this is the sanity read
2:18:20
client for fetching data through queries if you set the use CDN part to false
2:18:26
this will make sure to cache whatever content you request for 60 seconds after 60 seconds you'll get a newer version of
2:18:32
the data but in between the content will be delivered from the sanity CDN network
2:18:38
if you remember this is the ISR data fetching strategy next we have a lib
2:18:43
image. DS and this is simply an image URL builder for images uploaded on
2:18:49
sanity studio so we can use on the front and side we won't need it as we'll use a markdown plugin instead so we can remove
2:18:56
it from here next we have sanity schema types right now with empty types later on
2:19:03
we'll create our own sanity schemas and Export them so that our entire application knows what kind of fields
2:19:10
will each startup or each document will have we have our envs where we list which kind of envs we need for our
2:19:16
application and finally there's the structure where you can decide how do you arrange your schemas do you want to
2:19:22
group them add specific schemas on top or others at the bottom you do it here and finally you're asking how does the
2:19:30
sanity Studio get surrendered within our app well they have added a studio page right here where they show their Studio
2:19:37
as simple as that so in this chapter we have successfully set up sanity I also
2:19:42
told you a bit about why I think it's super useful and the reasons why we're using it and we also went through all
2:19:48
the files that it autogenerated for us to make the setup easier now in the next chapter we'll focus on creating your own
2:19:55
sanity schemas so we can structure the types of the documents in our database let's do that
Sanity Schema
2:20:02
next now that you know everything about sanity how to set it up and which files it generates let's use it to create our
2:20:09
own database structure whenever you're starting to work on any backend or any kind of database structure specifically
2:20:17
first think about what do you need in our example we need to store startups
2:20:22
submitted by a user of course that includes the user information that submitted those startups in the first
2:20:29
place and then we need to group those startups into some kind of playlists so we can show them as editor pics or
2:20:36
startup of the month day honors and so on so in simple words this is how a
2:20:41
database structure will look like we'll have a startup and each startup will have a title a slug which is kind of a
2:20:49
unique name or ident identifier for that startup the author that created it so let's quickly talk about that the author
2:20:56
will be authenticated through GitHub so we'll automatically get its ID name username email image and bio each
2:21:04
startup also has to have views descriptions category image and then the pitch itself which is going to be in
2:21:10
markdown format and once we have the actual startup then we can have
2:21:16
different playlists in which we can categorize those startups and then retri them I'll either put the link to this
2:21:22
entire flow somewhere in the GitHub readme of this project or images pointing to these different documents
2:21:28
either way creating these additional documents that would further explain the application to you is something new that
2:21:34
I'm trying out so if you like that please let me know down in the comments but with that said let's explore this
2:21:40
second graph that in even more detail explains how the app will work this is our app which will then hook up to next
2:21:48
a to authenticate our users and create a session if a session does not exist
2:21:53
we'll head over to GitHub ooth authenticate the user get the user information and then create the session
2:22:00
for that user if a user exists then we'll make a call to sanity to find that
2:22:06
user as an author if that user is not an author yet if they don't exist we'll
2:22:11
create a new author but if the author exists then we'll return that author and
2:22:16
then they'll be able to create different startups I hope this makes sense so let's get started by doing exactly that
2:22:22
let's create a schema for our author I'll head back over to Sandy schema
2:22:28
types and I'll create a new file right here which is going to be called author.
2:22:34
TS pretty straight forward right you will Define the author here as you would
2:22:40
in let's say you say export const author is equal to Define type and this
2:22:48
is coming from sanity and then you pass in an object with a schema definition where you can pass the
2:22:54
name equal to author you can pass the title which is going to be the capitalized version of that then you can
2:23:01
pass the type of this which will be a document finally you can use an icon for this document which is going to be a
2:23:08
user icon and we'll import this from sanity icons and then you define the fields that each author will have which
2:23:15
is going to be an array of fields where each field will be a defin field
2:23:21
call inside of which you pass a schema field definition such as name of the
2:23:27
field is going to be an ID and then the type of the ID will be number and we can
2:23:33
now duplicate this a few times to create all of the other necessary Fields so let me do just that 1 2 3 4 5 I think that
2:23:42
should be enough the second field will be name each author has to have a name of a type string then we'll have a
2:23:49
username as as well which will'll pick from GitHub that'll be of a type string
2:23:55
we also need an email of a type string we're going to have an image which is going to be their Avatar image of a type
2:24:02
URL and finally we'll have their bio which is going to be of a type text we
2:24:07
get all of this from GitHub ooth finally we can go outside of this array of fields and say
2:24:13
preview Select Title name so this allow us to select
2:24:20
those authors by name and preview them great believe it or not this is our
2:24:26
author type we're already exporting it so the only thing we have to do now is to use it we can first use it within the
2:24:33
index DS within the schema types and here we can use it by simply saying author within this array and then
2:24:40
importing it from the schema types author next we need to structure this schema in structure. DS so let's head
2:24:47
over to structure. DS and here we can list different things that sanity provides so as that list we list them by
2:24:55
content and then we can Define the items here instead of just having one items
2:25:01
and then a single s document type list item I'll copy this part right here and
2:25:07
open up an array of items where the first one will be a document type list
2:25:13
items of a name author with a title of authors and it looks like have an extra
2:25:19
s right here it's list item and there we go now we're good while we're added why don't we go ahead
2:25:25
and create a startup schema as well you now already know how to do that you can go to schema types and create a new type
2:25:33
startup. TS to quickly get us going we can copy everything over from the author
2:25:39
paste it in the startup in this case we won't be needing the icon so we can delete it and we can modify the name of
2:25:45
this type such as startup capital S for startup in the
2:25:50
title also of a type document and now we can Define all the fields in this case
2:25:56
we don't need the ID because we'll have the slug so let's say slug type Slug and
2:26:02
check this out we can provide options and say source of this slug will come from title so it will actually be
2:26:09
autogenerated for us by sanity based on the title for example if a title is this
2:26:15
is a great post or a great startup it'll simply generate something like
2:26:21
this is a great startup or if necessary it'll also provide some additional
2:26:27
unique identifier info to make sure that it's not the same as any other slug or title next we can have a title which is
2:26:34
going to be of a type string and let's actually put the title above right
2:26:39
here next instead of the username we can have the author and this author will
2:26:45
actually be of a type reference and then we have to give it an additional property of two so reference to what and
2:26:53
it'll be a reference to a type of author next we can Define the number of views
2:26:59
that each startup has and it'll be of a type number we can define a description
2:27:04
for each startup which will be of a type text next we'll have to define the category of each startup it'll be of a
2:27:11
type string for now there's definitely a more fitting type for this category such as an enam or just providing couple of
2:27:17
options that they can pre-select from but in this case I'll just keep it a regular open string for the sake of
2:27:23
Simplicity and I'll also show you how to add additional validation on it you can
2:27:28
open up a new Arrow function here get the rule through params and then Define
2:27:33
the rule by saying rule. Min it's going to be minimum one it's going to be Max
2:27:40
20 characters it's going to be required and if we don't pass it we'll say
2:27:45
something like please enter a category let's also create two additional feed so
2:27:50
I'll copy this description one and paste it below this one will have a name of image and type of URL of course you
2:27:58
could use sanity to store images here in this case I just opted for pasting the URL of an already uploaded image just
2:28:06
for the sake of Simplicity but after this video is done this is definitely one of the many optimizations that you
2:28:11
can make and we can also add a validation for this one by defining a rule and saying that this image is
2:28:19
required finally we can duplicate theine type one more time and we can call this
2:28:24
pitch which will be of a type markdown great our second schema is done we can
2:28:30
just change the variable name to Startup and then go back to index.ts and add it
2:28:36
right here next to author we can also go to the structure we can create a second
2:28:41
part of this array I'll actually make sure to duplicate it here and instead of authors this time we can say startup
2:28:50
and startups now let's go back to the startup for a second and in this case we
2:28:55
won't need this preview by name so we can remove that and keep in mind that the last field is of a type markdown
2:29:03
markdown field is a custom field which uses the official markdown plugin by sanity so let's go ahead and install it
2:29:10
by running mpm install sanity Das plugin Das
2:29:15
markdown this is also a pretty good lesson so I can show you how we can add additional plugins
2:29:21
and once it gets installed you'll have to go to sanity doc config.sys
2:29:50
array also for this to work we have to go back to one of the first files we worked on and that is app layout. TSX
2:29:58
where we have to add all of the general configuration in this case the marked and plug-in also requires additional CSS
2:30:06
so right here we can say import easy mde
2:30:11
slist SL md. min. CSS this will make sure that our
2:30:18
editor looks great now if you go back to your sanity Studio which is just localhost 3000 for/ Studio you should no
2:30:26
longer see an empty slate rather we should be able to create a few startups
2:30:31
directly from the dashboard let's first create one mock author by creating a new
2:30:37
author document for now we're still mocking all of this data but very soon we'll connect two santies database from
2:30:45
our application using their API for now I'll say one the name can be
2:30:51
Adrian username can be something like JS Mastery any email we'll do right now so
2:30:58
let's say contact JS mastery. proo I'll head over to Google and just copy the
2:31:03
image address of the JavaScript Mastery logo you can take out any other image address based it here and for the bio
2:31:10
I'll say nextjs Enthusiast and I'll publish the author great you can now see
2:31:16
one author in the author's array let's also go to startups and let's create a
2:31:21
new startup I'll actually go to the finished version of the application which you can find linked below and then
2:31:27
I'll copy some of the properties light here such as the title we can also get
2:31:32
the description right here the slug can be autogenerated based on the title pretty cool check this out author is the
2:31:39
reference to all existing authors so I can set it to Adrien the number of views can be set to one or zero by default we
2:31:47
have to add a category in this case the C category can be set to something like education and we have to add the image
2:31:54
so I will simply copy the image address that I already have here and finally you can write the entire pitch details using
2:32:01
markdown so I can say something like this is great all of you should vote for
2:32:09
my startup and of course you get all the benefit of including code blocks images
2:32:14
and more right here through the typical markdown editor that you're used to you can also see the Finish version right
2:32:20
here great with that said I'll go ahead and click publish it was published I got to say everything is behaving super
2:32:26
smoothly right here and now that we have one author and one startup the question is how can we now see them within our
2:32:33
application so in the next chapter I'll teach you how we can go from having this one fake card to fetching the real card
2:32:41
generated by a user from sanity studio and then later on in the course we'll of
2:32:46
course create our own create page so that our users can create new startups
2:32:52
without necessarily going to sanity Studio rather they're going to be able to do it straight from the app great now
2:32:59
let's learn how we can fetch real data from the database in order to fetch data from
Fetching Data and Type Safety
2:33:05
sanity we'll have to use something known as Gro queries Gro is sanity's open
2:33:11
source querying language which is powerful and intuitive so it's easy enough to learn you can describe exactly
2:33:18
what information your a needs join information from different sets of documents stitch them together and
2:33:24
basically do whatever you want you can go through a tutorial reading about how it works but I'll teach you all of that
2:33:30
in this video and even better than learning we can visualize and see exactly how this works in real time so
2:33:37
let's head over to for/ studio and then open the vision tab here you can write
2:33:42
the query and the params and see the results in real time check this out as the query I'll just enter an Ask risk
2:33:48
meaning give me everything related to sanity project from members to Grants
2:33:54
startups authors everything here you can see that the first property is our user
2:33:59
JS Mastery nextjs Enthusiast then if we go a bit down we should be able to see
2:34:04
our post as well now if you do something like asterisk and then zero inside of
2:34:10
square brackets you can just get the first property pretty straightforward right but what if you want to get all
2:34:16
startups well you would say give me everything where the underscore type property is
2:34:23
equal to Startup it's very similar to just writing PL all JavaScript and there
2:34:28
we go we get one property where we have all the information about that startup what's pretty cool is that it doesn't
2:34:35
return the author information rather it provides a reference to the author document but now how would we get only
2:34:41
the information that we need we don't necessarily need the updated ad property
2:34:47
the Rev and so on so how can we be a bit more specific about what do we return from a document well we can say give me
2:34:55
everything where type is equal to Startup and we can say defined slug doc
2:35:02
current which means it's not null this will go within the square bracket so we can just clean it here and put it right
2:35:09
here at the end I'll expand this a bit and then we can open up a new curly brace and within it say exactly what we
2:35:15
want to get back such as the ID title slot
2:35:20
undor created at we can also get the author let's also get views maybe the
2:35:28
description the category and the image and let's run fetch there we go so now
2:35:34
we get back only the information that we actually need but how do we also get additional information about the author
2:35:40
of that post in this same query well take a look at this I'll first space this all out so it's easier to see there
2:35:48
we go and now you can add an arrow pointing from the author and then you
2:35:53
can open up a new pair of curly braces there you can Define what do you want to get from the author such as the ID name
2:36:01
slug image and bio if I now run the fetch you'll see that the author will no
2:36:07
longer be just a reference rather we'll get all of the information about it I
2:36:12
don't think we have a slug for the author so we can just leave it like this great now of course we won't be making
2:36:19
calls that directly from sanity Vision right here rather I want to copy this query go back to our code specifically
2:36:26
to sanity lib and create a new file called queries.
2:36:33
TS here we can say export const startups query is equal to you can say
2:36:40
Define query which is coming from next sanity and then as a template string you
2:36:46
can pass the query right in and this will be the same as what we just wrote In The Vision part of Sanity Studio One
2:36:53
part that also would be good to add here is after this square bracket we can do some sorting by providing a straight
2:37:00
line and then saying order is equal toore created at and we'll set it as
2:37:06
descending which means that the newest one will appear on top that's going to look something like this now how can we
2:37:13
actually fetch this well let's go back to our home so that's going to be page.
2:37:19
TS in the root this one right here check how we currently have this fake post
2:37:25
right here well let's make it real I'll create a new variable const posts is
2:37:31
equal to await client coming from sanity client so you have to import it right
2:37:36
here at the top do Fetch and we're going to fetch what the startup squ this one
2:37:43
right here which we can import from queries now I will comment out the current posts
2:37:50
and before we go ahead and check them out on the homepage let's first add a conso log that's going to be json.
2:37:58
stringify posts and to style our output of the
2:38:03
console log a bit better we can say null and two this will just create some additional spacing so now if you go to
2:38:10
the terminal and open up a new Local Host window you'll see that we get an array of all the posts currently being
2:38:17
just a single post with all the information that we have about it and if you go back to Local Host 3000 check
2:38:23
this out the card with the real data just appeared and we can see it right here isn't that great that's pretty
2:38:30
simple right if you want to hand this app over to your clients that can use sanity Studio to add new posts in a nice
2:38:37
looking UI well you're good to go you can call it a day but soon enough we'll
2:38:42
also Implement our own create page so that other users can create additional startups directly from YC directory now
2:38:49
now we can remove this fake Post in the conso log because we have the new posts coming directly from sanity into our app
2:38:56
but remember that we don't yet have a startup card type it's going to be necessary for our startup card because
2:39:03
we're using typescript we need to be able to know exactly which properties does each startup have and typically
2:39:10
that's tedious work because you have to know the type of each one of these things you have to be precise in
2:39:15
defining it you have to know whether it's optional or not but instead of defining types manually sanity's new
2:39:22
tool generates types automatically it generates types both for sanity Studio
2:39:28
schema types and grock querying results to leverage that tool we need to add
2:39:33
sanity type gen there's a great documentation page with a video from sanity that teaches you how to generate
2:39:40
tab script types you can go through it but in this case you also have me so I'll explain it to you right here and
2:39:46
right now first things first is we have to extract the schemas we have already created you know I'm talking about this
2:39:53
ones here startup and author to extract those schemas we need to run an
2:39:58
additional command so let me expand this and let's run MPX sanity add latest
2:40:06
schema extract D- path equal
2:40:12
do/ sanity extract. Json and press enter
2:40:18
as you can see it's extracting schema and they have extracted it to extract. Json next we have to create a new file
2:40:25
in the root of our application called sanity dtype gen. Json and in here we
2:40:30
can add one configuration object I'll actually copy this object over from sanity learn and I'll make sure to
2:40:37
include this in the read me so you can copy this part as well this configuration will scan the application
2:40:43
for all Gro queries to create types additionally it'll also use the extract.
2:40:48
Json from the previous command we ran and it'll write a new types. TS file
2:40:54
with our other utilities and this generates command will create a new types. TS file I just noticed that in
2:41:00
here they were using the source folder which we're not using so we can remove that Source maybe it's already removed
2:41:06
for you if it's not just remove it and then run the command MPX sanity ad
2:41:12
latest type gen generate and press enter this just generated the typescript types
2:41:18
for 14 schema types and zero grw queries for now but later on as we add
2:41:24
additional queries and schemas we'll have to rerun this Command right well unless we automate it within our packet
2:41:31
Json so let's head over to Packa Json go under scripts and add a few new scripts
2:41:37
we can get those scripts right here from the learn but as I said I'll also provide this over to you in the read me
2:41:44
down below and paste those scripts once again I'll also remove the SRC from here
2:41:49
as we're not using that folder so it be just do/ sanity now you can just run mpm
2:41:55
run type gen so whenever we need to get new types you can just run this command and be good to go finally let's define
2:42:02
the type for the startup card to do that we can go to our startup card and create
2:42:08
a new type we can also export it export type startup type card which is equal to
2:42:17
we can use the omit property here for typescript which constructs a type without the properties of T which is the
2:42:23
first parameter we pass except for those in type K so what does this mean we'll want to use the startup type right here
2:42:32
from types. DS without the property of author for now and then we can say
2:42:39
and author is going to be optional and it'll be of a type author which we also
2:42:45
have to import from types you can also check those author and startup types
2:42:51
because they're all generated for you in the types. TS file pretty cool right no need to do this manually also I believe
2:42:58
we're using this in the home there we go startup card type so we can just import
2:43:04
it because we have exported it from the other file so we can just do this so we
2:43:09
can just import it right here by saying import startup type card from components
2:43:17
startup card oh looks like we we already have an import from the startup card so I can just add it right here by saying
2:43:23
comma and then get this as well and now if we Define this type we can say post
2:43:28
is of a type startup type card there we go you'll notice now that our typescript
2:43:34
is complaining just the tiny bit saying that property ID does not exist on type
2:43:39
author well let's check it out if I go to author we can see that ID is here as
2:43:45
a string but ID is optional so so instead of destructuring these
2:43:50
properties automatically what we can do is just destructure the author and then
2:43:56
here instead of author ID I think we're calling that in two places yep author ID
2:44:02
we can say author question mark dot uncore ID now we're good and here we can
2:44:07
use the author question mark. name to ensure that it will be there before we
2:44:13
call it finally it's complaining a bit about the category saying that category is possibly undefined so I will add a
2:44:20
question mark right here so it doesn't break her app if we don't have it great now you know how to fetch new posts from
2:44:26
the database through sanity's grck open- Source querying Language by first visualizing your queries in sanity
2:44:33
Studios Vision tab then creating them independently in our code calling them in a single line to see all of those
2:44:40
startups and even doing automatic type safety using santies type gen great work
2:44:46
in the next lesson we'll dive a bit deeper her into how next GS caches our data and how we can further optimize it
2:44:53
depending on the type of our application I'll show you specifically what's the best use case for the type of the
2:44:59
application where you want to get new posts shown immediately so let's do that
Cache and Live API w/ Next.js
2:45:05
next do you remember when we were setting up sanity client and we set this use CDN to true well this means that
2:45:13
sanity will cash content for 60 seconds and then revalidate the content after every 60 seconds
2:45:19
this is ISR incremental static regeneration this diagram shows how next
2:45:25
GS cache is done but it works similarly for sanity first of all we make an uncashed request we try to fetch
2:45:32
something setting the revalidation for 60 seconds it first looks into the cache to see if it can find the existing data
2:45:39
but if it misses then it has to go to the actual data source to get the data and then it sets it to the cache if less
2:45:47
than 60 seconds have passed after the set then making the same request to this URL will result in a cached request
2:45:54
which means that we will not try to fetch the new data from The Source rather we'll just go to our cash data
2:46:01
and return it but if more than 60 seconds have passed then this data will have become stale we'll revalidate go
2:46:08
back to the data source set this new data source to cache and then bring us back the data but let me show you how
2:46:15
this works in action I'll split my window in two on the left side we have our existing Local Host 3000 application
2:46:22
and on the right we have sanity studio now what would happen if we tried to create a new startup let's say by maybe
2:46:28
copying this document and then creating a new one where we can paste everything we just copied and of course we have to
2:46:34
change this lug to so I'll add one to it and I'll click publish now if you go
2:46:39
back and reload it will not appear not live and not even after many many reloads as you
2:46:46
can see why is that happening well because it's cached and if you refer to this
2:46:54
diagram we made a request to fetch the first post or all the posts at that time
2:47:00
but when we did that fetch we got the data containing only one post because the second one hadn't yet been created
2:47:07
but then even after we have created the second post we still try to refetch the data within 60 seconds which means that
2:47:14
it will not go to the new data it'll go to the cache to get it immediately so
2:47:20
only if we reload the page after 60 seconds the post will have appeared now to always get new data live and in real
2:47:27
time we'll have to go back to code and set to false to always get the new data so why is it even set to True by default
2:47:34
well because when you're fetching from cash and in most cases that'll be good enough whenever you don't need real-time
2:47:41
data such as for Block post or you could even argue that for our existing application you don't need to see the
2:47:47
new submitted startups every minute right so it's much faster to get the data from a CDN or from
2:47:54
Cache but for the purposes of this video and to show you the latest and greatest of new nextjs and even sanity features
2:48:02
we'll set it to false this way we'll get the latest data on refresh immediately but even that is not enough why get it
2:48:09
on refresh when we can get it immediately without needing to refresh the page for that we'll use sanity's
2:48:16
live content API allowing you to deliver deliver live Dynamic experiences to your users without the complexity and
2:48:22
scalability of the challenges that typically come with building realtime functionality to implement it within our
2:48:29
application we can first clear our terminal run mpmi server only this is a
2:48:35
package that will help us ensure that a specific module can only be used in server components next we can create a
2:48:41
new utility file within sanity lib and we can call it live. TS
2:48:49
within here we can import the server only package that we just installed and
2:48:55
we can also import Define live coming from next
2:49:02
sanity as well as import the client which is going to come from at
2:49:08
sanity SL SL client and then we can export const sanity fetch as well as
2:49:17
sanity live by making it equal to Define live to which we pass an object
2:49:24
containing the client we also have to quickly go to env. loal and change the
2:49:31
sanity version to say next public sanity API version and in this case I'll set it
2:49:39
to VX as we're using the latest features if what you have to type in here changes
2:49:44
I'll let you know somewhere below this video now we can go back to the homepage which is the page in the root folder and
2:49:51
we'll just have to make one change to our sanity fetch instead of saying const posts is equal to client fetch now we'll
2:50:00
change the bit by saying const data which we can rename to posts
2:50:05
is equal to await sanity fetch coming from sanity lib live to
2:50:12
which we can pass the options and then the query equal to the startup query no longer do we need the old fetch
2:50:19
we can just use the new fetch this will ensure to revalidate this page whenever
2:50:24
new changes are made and with that everything is set we can remove this unused client
2:50:31
import and we can go back to live for just a second to see if we have specified the import properly oh I think
2:50:37
I'm missing a forward slash right here there we go that's better but you can see that we're still not using this
2:50:43
sanity live variable so let's go back to the page scroll all the the way down and
2:50:49
below the section let's just call a self-closing sanity live component we
2:50:56
can import it directly from sanity lib live that's going to look something like
2:51:02
this we can save it and we are ready to test it out of course the only way to truly test it out is to create a new
2:51:09
startup and see whether it'll show up instantly now sure we could have first created the create startup page and then
2:51:15
you will be able to see the live changes but I just couldn't wait to to show this to you so one more time I'll split the
2:51:21
screen with sanity studio and we'll create a new startup through there I'll go to startups and I will copy all of
2:51:29
the information about this document just to make the creation of the new one a bit easier I'll paste it and I'll rename
2:51:36
it to something like new document and regenerate the slug now the moment I
2:51:42
press publish we should be able to see it on the left side let's check it out
2:51:47
publishing published and there it is it appeared at the top how cool is that
2:51:53
well it was pretty simple to implement using sanity and it just works like it allows you to play with different nygs
2:52:01
rendering strategies giving you the full flexibility of how and where you want to
2:52:06
show your data now you can add new data immediately on the homepage without your users needing to reload to see the new
2:52:13
info and this was actually a pretty cool way to see exactly how nextjs do do
2:52:18
caching or incremental static regeneration and so on hopefully this diagram and this practical segment of
2:52:25
this video where we played a bit with trying to fetch data from the cache first and then making it real time made
2:52:31
you better understand different data fetching strategies in
Real-time Search w/ URL Query Params
2:52:37
nextjs now that we have some posts in the homepage it is only natural to implement the search as well if I go
2:52:45
ahead and search for Adrien or even just JSM right here you'll notice that right now it's not
2:52:51
really working it's saying search results for JSM but it's showing us this one even though it doesn't contain JSM
2:52:57
in the title so let's make the search work as you can notice when you type something in it actually modifies the
2:53:04
query in the URL so first we need to retrieve that query within our application and then further filter the
2:53:11
fetch that we're trying to make we can do that at the top of the page. TSX
2:53:16
using the search Rams we have already extracted the query right here so what
2:53:22
we can do now is make more sense of it by creating a new variable called params
2:53:28
which is equal to an object that says search is equal to query or null if it
2:53:34
doesn't exist and now we can pass those prams as the second key and value pair
2:53:40
to our options object into sanity fetch so let's go into the startups query and
2:53:46
modify the query in a way that if there is is a search it'll return the matching search otherwise it should return all
2:53:53
results in a descending order so I'll add an additional and sign right here
2:53:58
and we'll check if there is no defined dollar sign search we are referring to the search parameter right here if it's
2:54:06
undefined or if category match the search so we're not only going to Surge
2:54:13
by title but rather we're going to Surge by category to or if author
2:54:19
name matches the search as well sometimes some people might want to search by the author name so essentially
2:54:26
what this part is doing here is checking whether a search exists or if search matches the category or if search
2:54:32
matches the author name and of course I miss the most important part which is or
2:54:38
title match search we're going to search by the startup title so this will simply
2:54:45
filter the documents where the title category or Au name matches the search
2:54:50
string using the match operator now if we save this go back and you can see we
2:54:55
didn't even have to reload search results for JSM actually show us the two matching JSM results whereas the new
2:55:02
document is not included if I search for Adrien who is the author of all three
2:55:08
documents we still get all three and if I search for new I think you can assume
2:55:13
what's going to happen we only get one new document how simple was that
2:55:18
everything works so seamlessly and super fast and don't forget that we also have
2:55:23
this clear button which will clear the search term now another cool feature we can do
2:55:29
is also filter by category so if I click on a specific category right here it'll
2:55:35
automatically set the query and the search term to that category if I quickly head over to studio and change
2:55:42
one of these documents categories to something like travel
2:55:49
and click publish back here immediately it's no longer showing for travel but
2:55:55
you can see that it changed and I can only filter by travel as well everything works so seamlessly now that that is
2:56:03
done just before we go ahead and create the form through which we can create startups from within the application I
2:56:10
want to make sure to see The Details page of each one of these startups that's the page that shows up when you
2:56:15
click details right here right now it's just a blank 404 so let's turn that 404
2:56:21
into a beautiful startup Details page just like
Understanding Partial Pre-rendering
2:56:28
this to get started with the details page let's open up our file explorer and
2:56:34
let's create a new page within app Root I'll create a new folder within the root
2:56:41
called startup and within startup we'll create another folder this will be a dynamic r
2:56:48
route so I'll give it a name of square brackets ID and within that folder I'll
2:56:54
create a new page. TSX now if you're doing this for the
2:56:59
first time this might seem like a lot of folders but trust me it'll all start
2:57:04
making sense very very soon the reason why we're doing this is to expose our
2:57:09
page on the URL slash startup SL2 or
2:57:15
three or whatever the ID of that startup is so we can show a new Dynamic startup
2:57:21
Details page for each different startup within this page let's run ource to
2:57:26
create a quick page and there we go it immediately appears under this URL so
2:57:32
now if you go back home and if you click on any one of these you can see that it automatically renates you to Startup and
2:57:38
then the ID of that startup now do you know how we can extract this ID from the URL and get it right here within our
2:57:44
code well we can get it through pramps so let's d structure the pams and let's also specify the type
2:57:52
I'll set the pams to be equal to a promise which will return an ID of a
2:57:59
type string that'll look something like this how do we know it's an ID because we name our folder that way then we can
2:58:07
say const ID is equal to in parenthesis
2:58:12
a weight for rams. ID and since we're using a weight we have to turn this into
2:58:17
an a sync function now we can return an empty react fragment which is going to look something like this and within it
2:58:25
we can return an H1 that will have a class name of something like text-
2:58:32
3XL and within it we can say something like this is a startup number and then
2:58:39
we can dynamically render it ID if you do that and go back you can see this is
2:58:44
a startup number and then we get the ID but this on its own is not super useful
2:58:50
we need to be able to take this ID and then fetch all of the details about that startup things like the date created the
2:58:58
title description the image the author all of that good stuff so how can we do
2:59:04
that well for a second let's create a new tab and go to localhost 3000 SL
2:59:10
Studio we can go to vision and we can modify our query a bit to now not fetch
2:59:15
all the startups but rather to fetch startup deta details the query will look something like this give me everything
2:59:22
where a type is equal to Startup and uncore ID is equal to dollar sign ID and
2:59:30
then here's the key part only give me element that matches that query then for
2:59:36
each one of these elements return the ID title slug created at author with it's
2:59:42
ID name username image and bio give me the views description C category image
2:59:49
and there's also the pitch which I think we're missing here we might also be missing it in all in the query for
2:59:55
fetching all startups now if you run fetch like this it'll say you provide
3:00:01
the pram ID but you didn't really give me the value for it so sanity Vision
3:00:07
allows you to pass the params right here so going back to our application we can copy this ID and we can now paste it
3:00:14
right here within a string so use single quotes right here to turn it into a
3:00:19
string and run fetch one more time we get null and I think that's because our
3:00:25
ID got parsed to show nicely in the URL most likely this was a character that
3:00:30
wasn't easy to parse as a URL so it's getting shown this way that's not a problem we can get a full URL from the
3:00:36
structure by going into startups and then we can inspect it right here if you do that you'll get the
3:00:44
entire thing along with its ID so here we have the correct one so if we go back
3:00:49
to Vision you can now pass the correct ID right here and now we get the complete startup
3:00:56
details so let's go ahead and copy this query and let's bring it back to our code we'll use it within sanity lib
3:01:05
queries and right below the startups query I'll create a new one by saying export const startup by ID query is
3:01:14
equal to Define query where we pass in a template string string and right in there we pass the full query oh and I
3:01:21
was partially right when I said that we're missing the pitch right here we indeed are missing it it's not like it
3:01:27
is here but we don't actually need it so this is the beauty of gr quering language in a sense that it allows you
3:01:34
to get only the data that you need on the homepage where we're showing not startup details but only the most
3:01:40
important information about the startup we don't necessarily need to show the pitch so we don't fetch it but here for
3:01:47
the details we definitely do fetch it so now that we are exporting this query we
3:01:52
can use it on the project Details page but before we do that I want to go over one thing with you we could have also
3:02:00
used sanity live fetch here but it's not like you're going to be on the details page and wait for the changes to happen
3:02:07
once you're there you wouldn't expect them to happen live right because you're viewing a specific version of that page
3:02:13
and I also wanted to show you how you can Implement different rendering strategies on the same page
3:02:18
and use one of which is the PPR strategy partial pre-rendering enables you to
3:02:24
combine static and dynamic components together in the same route it's pretty
3:02:30
crazy and it's completely new during the build nextjs pr- renders as much of the
3:02:35
route as possible and only if Dynamic code is detected like reading from the
3:02:41
incoming request you can wrap the relevant component with a react suspense boundary the suspense boundary Falls
3:02:47
fall back will be included in the pre-rendered HTML so nextjs here shows
3:02:52
an example of an e-commerce store where we have a Navar which is completely static or revalidated same thing for the
3:02:59
product information static or revalidated in some kind of a time frame like every 60 minutes seconds or
3:03:06
whatever it is but in general it's static but the cart and the recommended
3:03:12
products can be completely Dynamic only that part while the rest can be static
3:03:17
to to use all the benefits that I mentioned so far like speed efficiency
3:03:22
better developer experience and also SEO benefits that it offers and I would highly recommend watching this 11-minute
3:03:29
video by delba where she visually explains partial pre-rendering these are
3:03:34
some very nice Graphics that allow you to fully understand how this is working but for the time being I'll show you how
3:03:41
it works in a real example pink dots right here denote artificially delayed
3:03:46
responses for demo purposes like shipping estimates which you can see right here recommended products and
3:03:53
reviews these are always going to be dynamic because they have to make a request to some outside Source such as a
3:04:00
postal service to know when it can get shipped same things for recommended products because some algorithm has to
3:04:06
be ran to check out your preferences and shopping habits and finally there's the customer reviews which are always going
3:04:12
to be dynamic so now check this out if I reload see how this loaded immediately
3:04:19
because the product information doesn't really change that often and you have it right in front of you then this loads in
3:04:26
200 milliseconds and this one loads in 500 milliseconds pretty crazy stuff
3:04:32
right you can choose what you want to show dynamically and what will be there immediately for the users cached and
3:04:38
coming from a CDN next js's PPR really is the latest and greatest of rendering
3:04:44
strategies out there as it allows you to combine the best of both worlds so now let me teach you how to add it to your
3:04:50
apps first head over to next config TS and here we'll add an experimental tag
3:04:57
because it is experimental right now but soon enough it'll become stable and here you can say PPR and set it to
3:05:04
incremental we can also turn on some additional Dev indicators such as app
3:05:10
ISR status is set to True build activity is also set to true and build activity
3:05:18
position is set to bottom right these will help us visualize what is happening with PPR next back in the startup
3:05:24
Details page we have to export const a new flag called
3:05:29
experimental PPR is equal to true and now we can use sanity's client API to
3:05:36
perform incremental static regeneration or ISR to get the startup details we can
3:05:42
do that by fetching the post based on the provided ID const post is equal to
3:05:48
await client. fetch we pass in the startup byy
3:05:55
ID query and we pass in an object where we pass the ID as the first and only
3:06:01
parameter finally if there is no post we can return a not found this is coming
3:06:08
directly from next navigation else we can return something else from the post now for example we can render a post.
3:06:16
tile see how typescript immediately knows that we actually do have a title on the post going back to Local Host and
3:06:23
clicking on one of these posts opens up a 404 this page could not be found oh
3:06:29
that's happening because no post was returned so we redirected to a 4 or4 but why is that could it be that our query
3:06:36
is good but it actually cannot find a post under that ID similarly to what happened when we were trying to query it
3:06:42
with Insanity Vision let's try to conso log it to see what we're getting back I'll cons log this ID right here save it
3:06:50
and click on one of these posts right here as you can see we get the full ID
3:06:56
but at the end we have this percentage sign character even though in the original ID it doesn't seem to be there
3:07:03
I also opened a second post that we created and would you take a look it ends with different numbers but then it
3:07:11
has the same percentage 7D appended to it at the end which makes me pretty sure
3:07:17
that I already know what the problem is can you catch it try to debug it with me when you click on the details of any one
3:07:24
of these cards it appends an additional character to the ID as you can see right
3:07:30
here so where's the issue let's try to pinpoint and centralize it is it in the
3:07:36
details well yes most likely so if we go to the code and if we go to the startup
3:07:42
card take a look I made a mistake you most likely didn't have this mistake you most likely properly wrote it I hope you
3:07:49
did but I added an extra curly brace right at the end of this string so if I
3:07:54
remove it and click details perfect we get a title of each different document
3:08:01
even though you might not have had this issue on your end I hope this little debugging session was useful but with
3:08:06
that in mind the fact that we're now getting a title means that we're successfully fetching post details from
3:08:13
sanity with the PPR strategy enabled in the next lecture will code out the UI of
3:08:20
the startup Details page and I'll further explain which parts can we leave as static and which ones will make
3:08:26
Dynamic to utilize the full power of VPR great work so
Startup Details
3:08:31
far let's get started with startup Details page by creating a section right
3:08:37
here at the top this section will have a class name
3:08:42
equal to pinkcore container we've seen that before and know exactly ly what it
3:08:48
does I'll also give it a exclamation mark m-h 230 pixels which will overwrite
3:08:55
it to a bit of a smaller value there we go that's looking good right within it I'll create a P tag that'll have a class
3:09:03
name equal to tag and it'll show a formatted date so let's call a format
3:09:08
date function coming from our lib utils and pass the post question mark doore
3:09:14
created at property right within it and there we go October 14th 2024 next
3:09:21
let's move this H1 right within it and we'll change the Styles just a tiny bit
3:09:26
by setting the class name to be equal to heading there we go that's already so much better right below it let's create
3:09:33
another P tag that will have a class name equal to subheading and it'll also have a Max W of 5 XL with an exclamation
3:09:41
mark at the start and that will render the post dot description there we go
3:09:47
look looking good right below this section we'll create another section and this section will have a class name
3:09:53
equal to section uncore container within which we can render an IMG tag with a
3:10:00
source equal to post. image there we go that's looking good we can also have an
3:10:06
ALT tag of thumbnail and a class name equal to w-o h-auto and rounded D excl looking
3:10:16
good right below it let's create a div and that div will have a class name
3:10:23
equal to space- y-5 margin top of 10 to divide it a bit
3:10:28
from the top Max W of 4 XEL and a margin
3:10:33
EXL Auto and right within it we can create another div to help us with positioning with a class name equal to
3:10:41
flex between and a gap of five in between the elements within there we can
3:10:46
render a link of course only after we import it from next link and give it an
3:10:53
hre of sluser slost do author question mark. ID so
3:11:03
we're creating a link to point to the author Details page which we'll soon create let's also give this link a class
3:11:11
name equal to flex gap of two items Das Center and the margin bottom of
3:11:18
three within it we can render an image with a source of post. author. image
3:11:26
with an Al tag equal to Avatar a width of 64 a height of 64 and a class name of
3:11:35
rounded daso to make it a full Avatar and drop shadow LG we have to import the image
3:11:43
tag from nextjs and if we save this now you'll see see a great looking profile photo right below this image let's
3:11:50
create a div within which we can have a P tag with a class name equal to text-
3:11:57
20-m medium within which we can render the post. author. name and we can also
3:12:03
duplicate this change the text to something like 16 and also give it text black of 300
3:12:12
with an exclamation mark within which we can render at post. author. username so
3:12:20
we can show both the name and the username right below it of course the author page doesn't yet exist but it
3:12:26
will soon let's go below this link and let's create another P tag that'll have
3:12:32
a class name equal to category dashtag so I think you know what it will render
3:12:38
the post. category here we go perfect now right below this div we can create
3:12:44
an H3 that'll have a class name equal to text D30 D bold and it can say something
3:12:53
like pitch details or startup details if you will and right below it we can
3:12:58
render the pitch details which come in a markdown format to parse and convert
3:13:04
markdown into an HTML string we need to install an additional package it's this one right here called markdown it and it
3:13:11
says it's a markdown parser done right fast and easy to extend you can just in
3:13:17
install it by running mpm install markdown-it and then you can use it very
3:13:22
simply so let's do it together I'll open up the terminal clear it and run mpm install
3:13:30
markdown-it once it gets installed we can get the pars markdown content right
3:13:36
here at the top by saying const pars content is equal to
3:13:43
MD which we have to import at the top by saying import markdown it from markdown it then right
3:13:54
here we can Define MD is equal to markdown it and finally on this pars
3:14:00
content we can say md. render post question mark. pitch or an
3:14:07
empty string in case it doesn't exist so this will properly pars the markdown content so we can display it as HTML and
3:14:15
you can see that markdown it is complaining a bit saying that we don't have the necessary types for it so if
3:14:20
you hover over it it's going to give you the command to install the type declarations for the library so just
3:14:27
copy it and paste it in the terminal then the warning will be gone
3:14:33
and you'll have all the necessary types great now that we have this parsed content we'll have to set it as
3:14:40
HTML so let's do that right here below this H3 by checking if we have access to
3:14:47
to the par content if we do we can render an HTML 5 semantic article tag
3:14:53
which can be self-closing in this case I think we should be good and on it we can use a dangerously set inner HTML
3:15:01
property now react normally escapes any HTML to prevent xss attacks cross side
3:15:08
scripting attacks rendering the content as plain text but when you want to insert raw HTML like the parsed markdown
3:15:16
you must use dangerously set inner HTML to tell react that the content is safe and should be rendered as HTML so right
3:15:23
here we can Define uncore uncore HTML to be equal to par content we also need the
3:15:30
second part of this stary and here we can say ptag with a class name of no
3:15:38
result which can say no details provided if we save it you can see Pitch
3:15:45
details and you can see all the testing markdown that we have passed using the sanity Studio markdown editor we can
3:15:52
style it further by giving this article a class name of pros this will allow
3:15:57
tailin CSS to automatically change a lot of different styles to make it more readable and to actually parse it there
3:16:03
we go this is looking so much better let's give it a Max W of 4 XEL so it
3:16:09
doesn't take the full width of the screen on larger devices font work sense
3:16:15
to match our application and let's give it a break-all which will apply the word
3:16:21
break property great now we can go below this div and we can create an HR a
3:16:27
horizontal rule with a class name equal to divider to divide the pitch details
3:16:34
from the next section later on right here we'll show editor selected startups
3:16:40
which are some recommended startups for us to check out since we checked out this current one we're viewing so we can
3:16:46
kind of continue checking out additional ones while staying on the app so for now I'll turn this into a to-do so we can
3:16:53
implement it later on but let's go below this section and let's create another very small but very very important
3:17:00
section and that one will make the fact that we're using PPR on this page makes sense because everything we have
3:17:06
rendered so far is static content whatever the pitch details we have the thumbnail the title we don't need to
3:17:14
constantly dynamically refetch or revalidate we're okay that sometimes this data is stale and can be changed
3:17:20
later on but we will Implement an additional piece of this page that we
3:17:26
need to update frequently basically in real time it'll be completely Dynamic so as you learned from the start of this
3:17:32
video whenever you want to make something dynamic in PPR you have to wrap it in a suspense coming from react
3:17:40
and that's actually a react feature allowing you to provide a fullback in case we cannot render something
3:17:46
something new or something to show while that something new hasn't yet rendered
3:17:51
or been fetched so if we cannot yet fetch it we can render a skeleton property coming from shaten so let's go
3:17:59
ahead and install it by running MPX shaten add latest add skeleton there we
3:18:07
go it has been added and we can now import it right here at the top coming from components UI skeleton and suspense
3:18:15
is of course coming from react so make sure to properly import it we can actually add it right here at the top to
3:18:22
this skeleton we can also provide a class name equal to view- skeleton and
3:18:29
within the suspense after you have given it a fallback you can choose to add the code that will be rendered dynamically
3:18:37
so for that piece of code let's actually create a new component in the components
3:18:42
folder I'll create a new file called view Dot TSX I'll run
3:18:51
rafc and I'll now render that component right here within the suspense by saying
3:18:57
view coming from add components SL viw and to it I'll just pass the ID equal to
3:19:03
the ID this is the ID of the post we are currently on so what kind of view am I
3:19:09
even talking about here well if you check out the final version of the application check out this little thing
3:19:14
at the bottom right I know it's it's super super small but once again I really wanted to show you how we can
3:19:21
make PPR truly shine this piece of data will be rendered dynamically whenever it
3:19:27
changes in real time thanks to sanity of course but the rest of the page will be completely static exactly as that nextjs
3:19:35
example where they had an e-commerce store where we had the product details which were render statically but then
3:19:41
some additional posts or views or whatever it was was rendered dynamically so now we can go into the view and we
3:19:48
can develop the dynamic part of our PPR page that's going to look something like this we can first destructure the ID
3:19:54
from props and say that it's ID of a type string then we can return a div
3:20:00
with a class name equal to view container within which we can render a
3:20:06
div that'll have a class name of absolute minus
3:20:12
top-2 and minus wr-2 can you guess what will go into this container well it'll
3:20:18
be that little ping that you can see right here this light indicating to us
3:20:23
that it is live so to implement it I'll actually create another component in the
3:20:28
components folder and I'll call it ping. TSX run rafc and I will import it right
3:20:36
here within the div by saying ping and calling it as a self-closing component
3:20:42
below this div we'll render another P tag with a class name of view text
3:20:48
within which I'll render a span that'll have a class name of font Das black
3:20:53
that'll render the total number of views so for now let's simply render 100 as a static number and say views if we go
3:21:01
back to application you can see 100 views and then ping right here at the top right that's good all good things
3:21:07
take time so now we can dive into ping and we can Implement that little pinging
3:21:12
light by giving this div a class name of relative with within which we have another div with a class name is equal
3:21:20
to Absolute minus left- 4 and top-1 so
3:21:26
we can properly position it within which we have a span that has a class name of
3:21:31
flex and size- 11 pixels within square brackets within which we have another
3:21:38
span with a class name equal to Absolute inline-flex
3:21:45
h- full w- fo animate dping rounded Das full BG
3:21:53
primary and opacity of 75 there we go you can kind of see it right now at the
3:21:59
bottom right and below this span we'll have another span that'll have a class name is equal
3:22:07
to relative inline-flex size-1 pixels same as before rounded Das
3:22:15
full and and BG primary so basically we'll have one that is always active and
3:22:21
then we'll have one that pings indicating it's live interactivity great this is now looking
3:22:28
good now we have to write a separate sanity query to get the total number of views for a post with the given ID to do
3:22:37
that you already know the drill we have to go into sanity queries where we currently have
3:22:42
two so we can create a third one by saying export const startup uncore views uncore query
3:22:51
is equal to theine query to which we pass the actual query this query will be
3:22:56
a bit simpler we'll say something like give me everything where off a type
3:23:03
double equal to Startup and if the underscore ID is equal to dollar sign ID
3:23:10
and give me only the first element and only return the ID and the views pretty
3:23:16
simple right now we can copy this query go back here and say const in
3:23:24
curly braces views which we can rename to Total
3:23:30
views is equal to a weit client coming from sanity do withth config to which
3:23:38
will pass use CDN is set to false so you can also manually define whether you
3:23:43
want to use CDN or not with inline configuration ation now let's turn this into async since we're using a weight
3:23:49
right here there we go and finally after the width config we also have to add dot
3:23:57
fetch so which Creer are we fetching we're fetching these startup views query
3:24:04
to which we have to pass params of ID now let's make sure to properly close
3:24:09
this right here looks like I had a typo and this is now looking so much better and it makes more sense we also have to
3:24:15
add the ID as a Pam perfect and now we can get access to the total number of
3:24:21
views and dynamically render it right here currently we have only one views we
3:24:27
can do some additional parsing to remove the letter s in case it's a singular number a quick trick is to just say
3:24:33
views and then say colon that way views one views two views no matter how many
3:24:39
it's all good that's if you want to be lazy but I challenge you to create a function called format number that
3:24:46
actually takes into consideration whether a number is singular or plural or whether it needs an S at the end or
3:24:52
not and then adds it correspondingly with that in mind and considering the fact that we specifi the UCD into false
3:24:59
the number of views whenever it changes will automatically be reflected on this page later on I'll also add a little
3:25:06
to-do right here to modify or update the number of views whenever somebody sees
3:25:14
this post more and that soon with that said we have successfully implemented the dynamic part of the startup Details
3:25:21
page and the static part has been implemented too which leaves us with the completed startup Details page of course
3:25:29
we have to still update the views and then show other relevant posts similar to this one we'll do that soon but for
3:25:36
now this is great so next St we'll tap into sanity right client functionalities
3:25:42
meaning being able to modify some data directly within our application this will allow us to create new startups but
3:25:50
even sooner than that it'll allow us to update the number of views so that we can see the full benefits of
Sanity Write Client
3:25:58
PPR so far we've implemented PPR partial pre-rendering on the startup Details
3:26:04
page but we can't really see any difference yet as everything seems static as we're not updating any kind of
3:26:11
data to increase the number of views in our database at the exact moment somebody visits the page we'll have to
3:26:18
set up a new sanity right client that allows users to perform right operations
3:26:23
so far we only performed read operations now to set up a right client in sanity
3:26:29
we need to generate a token with right permissions through the sanity manage website so visit your dashboard navigate
3:26:36
to the sanity project you've created head over to API go to tokens and add a
3:26:42
new API token specify the name something like create and update startups and give
3:26:49
it the editor access the ability to write access to all data sets and click save copy the token info you were given
3:26:57
and head over to env. loal there you can add sanity write token and make it equal
3:27:06
to the Token you just copied notice how this one doesn't have the next public well that's because this is a more
3:27:12
serious action which not everybody should be able to perform and and it can only happen from the server side nextjs
3:27:19
will automatically reload all the envs as soon as this happens now head over to
3:27:25
sanity env. DS that's this file right here and below the project ID also
3:27:32
export const token and make it equal to process.
3:27:38
env. sanity wror token next we have to create a new
3:27:44
file under sanity lib and as we have created client. TS
3:27:50
now we need to create a new file called Write client. TS to create it we can
3:27:56
copy what we have here in the client and paste it for the right client at the top
3:28:03
as I have already mentioned this code can only be run on the server so we're going to import server only all of the
3:28:10
other things which we're importing are going to be here such as the API version data set project ID
3:28:16
and in this case we also need to get the token so we can say export con write
3:28:25
client create a new client with the project ID data set API version use CDN
3:28:32
set to false and finally we also have to give it a token we can also add one fail
3:28:39
save to say if there is no bright clientconfig and then. token after dot
3:28:46
in that case we can throw a new error saying something like write token
3:28:53
not found just so we know what's wrong and now that we have access to this right
3:28:59
token we can actually finally update the number of views by going to the view
3:29:06
component we can remove this to-do and say await right
3:29:12
client Dot and we can call a DOT patch on it patch is used for updates we want
3:29:19
to patch a document with this specific ID and we want to set the number of
3:29:25
views to be equal to Total views + one and we want to commit that action by
3:29:33
saying do commit and that's it with this approach these two requests will execute
3:29:39
sequentially and you won't see anything on the UI until they are executed instead you'll see the skeleton to to
3:29:46
avoid that and to run this update view in the background while we see the rest of the results immediately we can use
3:29:53
the unstable after functionality allowing you to schedule work to be executed after another response is
3:30:00
finished this is useful for tasks and other side effects that should not block the response such as logging and
3:30:06
analytics or a perfect case updating the number of views it can be used in server
3:30:12
components server actions route handlers and more and it looks something like this import unstable after as after and
3:30:21
then you call it in this case we want to schedule the work after our response to getting views is done we'll then update
3:30:28
the views in the background without blocking the UI to do that we just have to do this import unstable after as
3:30:36
after from next server and then wrap this await into after close it like this
3:30:42
and set that into its own async function that is it now if you go back
3:30:51
to your application you'll notice that unstable after must be explicitly enabled by setting the experimental that
3:30:57
after to true in our next config so let's head over to next config and here
3:31:03
along with PPR we can also set after the true if you do that and reload the error
3:31:09
is gone and the number of views switched to two check this out I'll reload a couple more times
3:31:17
check how gray this is the rest of the content isn't even changing and it's
3:31:23
here immediately doesn't feel like anything is happening like if I go back
3:31:28
and if I go to this document I mean it is just super quick the only part of the website that
3:31:36
updates is this little part at the bottom right which is the number of views super cool I think I'll continue
3:31:42
reloading it a few more times but even at this point it still may not be clear that this is PPR right so I will
3:31:50
actually demonstrate it to you I'll open up sanity Studio on the right side and keep looking at the project details on
3:31:56
the left I'll head over to startups and I'll find this last startup that I
3:32:02
updated we can see the number of views is 22 now I'm going to change the title of this startup in sanity studio and
3:32:09
reload the page check this out I'll change it to something like new JS mastery. proo platform yep
3:32:20
that's a cool new startup we're working on so let me click publish and even if I
3:32:27
reload well it changed immediately it's possible that I hit just the right reload time but if I change it again to
3:32:34
something like new new new Js Mastery
3:32:39
Pro platform and click publish if I reload well it changed the
3:32:45
immediately looks like the news about the new upcoming platform can't wait to get leaked but let's see why is that
3:32:52
because right now it seems that everything is live and not cashed at all we are fetching the number of views
3:32:58
right here using the client and we specifically said the UCD and fals
3:33:03
that's okay but what about these startup details so if we go to Startup details
3:33:09
here we're using the regular client and this client oh it has a UC and set to false
3:33:17
when we were testing something we set it back to false just to show it but for now I can set it to true so it'll
3:33:24
actually cache things so now if I go back and change
3:33:29
this to something like brand new Js Mastery Pro platform and click
3:33:36
publish and then reload here you can notice that this will not actually
3:33:41
update for another 60 seconds that's because the data is cached it's coming
3:33:46
from a CDN the views are indeed updating the title stays the same and that my
3:33:53
friends is PPR for you hopefully now you understand how this is working behind the scenes the startup details use ISR
3:34:01
incremental static regeneration which revalidates the page every 60 seconds so
3:34:08
any change made in stti studio or editing the database will make the changes appear on the website once the
3:34:15
cach is refreshed meanwhile views use SSR service side rendering providing
3:34:21
fresh data with each user request so if I reload 60 seconds have passed we get
3:34:27
the new data and now it's going to be cached until it changes perfect that was
3:34:33
a good one now you truly understand how to use PPR next we will revisit the
3:34:39
author authentication flow so we not only log in using Google allo but we
3:34:44
actually create a real author in our database that will then be capable of
3:34:50
creating new startups directly within the YC directory app let's do that
Author Authentication Flow
3:34:57
next I've shown this graph to you before right and basically what it says is
3:35:03
depending if there is a session or not we have to make sure that the user that
3:35:08
is authenticated also is created as an author within our database and if they're not we need to create one in
3:35:14
their name so to do that we'll have to create a sanity query to see whether an author with a specific GitHub ID exists
3:35:23
let's head over to queries and let's create a new query by saying export
3:35:28
const author by GitHub ID query is equal
3:35:34
to Define query and we can say something along the lines of give me everything
3:35:40
where underscore type is double equal to author and the I ID of the author is
3:35:47
equal to dollar sign ID then give me only the first element that matches and
3:35:52
for that first element return the following things an underscore ID the ID
3:35:59
name username email email image and bio now
3:36:06
let's go over to o. TS and we have to write some call backs these are
3:36:12
functions that are executed after successful authentication by next off in this graph that callback would be
3:36:20
somewhere right here where we're authenticating and when we get the successful information about the user
3:36:27
currently we just create a session and return it but now whenever we create a
3:36:32
session we also want to do this check that we just created the query for so alongside providers create callbacks
3:36:40
which is an object and create a first call back async sign in to check whether
3:36:46
our user already exists in our database or not and then depending on that created right here we get access to the
3:36:54
newly authenticated user their account and their profile we can check whether this is an already existing user by
3:37:00
saying con existing user is equal to await client. fetch author by GitHub ID
3:37:11
query to which we pass params as ID and of course this
3:37:17
client has to come from Sandy specifically this ID is going to be
3:37:22
referring to the profile question mark. ID coming from GitHub ooth now we can
3:37:28
check if there is no existing user then we can use sanity right client
3:37:36
to create a new user document or new author document by saying await write client which we have to
3:37:43
import from sanity create where the type is equal to
3:37:50
author ID is set to profile question mark. ID name is set to user question
3:38:00
mark. name username is set to profile
3:38:05
question mark di login email is set to user questionmark
3:38:11
doil image is set to user mark. image and bio is set to profile question mark.
3:38:18
bio or an empty string if it doesn't exist now you can notice how I had to
3:38:24
actually repeat user and profile many times what would have been better is to Simply extract information from this
3:38:31
user or profile by destructuring it so we can destructure from user the name
3:38:37
the email and the image and from profile we can destructure what ID login
3:38:46
and bio now if we do that we can remove all instances where we mention those things
3:38:54
and we can just refer to those things themselves and if you have the same name of the key and the value that means that
3:39:00
you can just refer to it like this without specifying the name it's just
3:39:06
like this but for username it's going to be login so we have to specify it still
3:39:11
still much cleaner than it used to be finally we can go below this if statement and then return true
3:39:19
to continue the sign-in process after a successful signin we'll need to create an author ID from sanity to use it for
3:39:27
our profile or when creating a new startup so let's modify the default JWT
3:39:33
token and add the author ID to it we can do that by creating a second call back
3:39:39
right here right below the async sign in we can create async
3:39:46
JWT where we get the token the account and the profile there we can check if
3:39:52
account exists and if profile exists then we can get the user from
3:39:58
sanity by saying const user is equal to a weit client. fetch author by GitHub ID
3:40:06
query where we specify the ID to be equal to profile question mark. ID oh
3:40:13
and I just noticed above we destructure the ID from profile so we don't have to
3:40:19
explicitly mention it here we can just say ID now we can extend this ID with
3:40:24
the user ID by saying token. ID is equal to user doore ID and finally we can exit
3:40:32
out of that if and return the token this will allow us to connect a specific
3:40:37
GitHub user with a sanity author that can then create a startup finally in
3:40:42
order to use the ID we need to create a third callback function called session where we get
3:40:50
access to a session and a token and we need to pass the profile ID
3:40:57
from the token to the session by saying object. assign
3:41:02
session where we set the ID to be equal to token. ID and then we return the
3:41:09
modified session great now we can go to any page
3:41:15
for example we can go to our homepage and here we can extract a session and
3:41:22
from it we can get the sanity ID of the author for that user so let's do it by
3:41:28
saying const session is equal to await off coming from at SLO and if you try to
3:41:37
console.log session do ID you'll see that typescript will
3:41:43
complain a bit say saying that session is possibly null we can easily fix that
3:41:48
by creating a new file right here in the root of our directory and call it next o
3:41:56
or next- o.d. TS within it we can declare a new
3:42:03
typescript module called Next o which will have two interfaces
3:42:10
interface session that'll have an ID of string
3:42:16
and it'll also have an interface
3:42:21
JWT which will have an ID of string as well if you do that the session now
3:42:28
knows that it has an ID so let's give it a shot now if you go back to the homepage
3:42:35
you'll notice that the only thing you have to do to get rid of this warning is to add a question mark right here and
3:42:41
you might have noticed that on my screen there was an error right there 5 Seconds ago but now there's no error well
3:42:48
sometimes nextjs will throw some random errors as I'm still working on the experimental version of nextjs so just
3:42:54
so you know if something weird is happening for you too and you cannot find where the error is originating from
3:43:00
just try to reload your terminal and then run it one more time it might help just to fix things you know turn it off
3:43:07
and then turn it on again type of situation but with that in mind if we do that and you reload on the homepage you
3:43:14
should see a conso log for this session initially the conso log should be
3:43:20
undefined and we can see undefined right here that's because we were left logged
3:43:26
in before we created all the functionality to create a new ID to hook
3:43:31
it up with the author so to fix that let's log out and let's log in one more
3:43:37
time and there you'll see a server error problem with server configuration if you open up the
3:43:44
terminal you'll see that it's coming from o and specifically it's complaining
3:43:49
about not being able to find the underscore ID so we might need to add a
3:43:55
question mark right here saying that sometimes the user might not be there but why would it not be there in
3:44:02
the first place let's check our query to be sure we are trying to fetch the
3:44:07
author by GitHub ID query by defining the query that gets everything of a type
3:44:13
author and the ID and the ID is equal to dollar
3:44:19
sign ID where we get the first element and then we return all of these properties for it this is looking good
3:44:25
to me so let's give it one more shot but before we do you have to make sure that the author hasn't been generated or if
3:44:32
it has we'll have to clear it by deleting it so now if we try to log in one more
3:44:41
time oh it's actually asking us whether we want to authorize it which is great
3:44:46
so let me authorize my user we're getting redirected which is good we get the same information right here at the
3:44:53
top as before but this time if you go to sanity Studio to authors you'll be able
3:45:00
to find a new user with complete oath data populated such as the name username
3:45:06
email image and the bio coming directly from GitHub but a bigger question is can we
3:45:14
see that session ID D in our console log and for the time being the answer is no
3:45:20
it is undefined so let's debug it further we're not getting the result we want we
3:45:26
create a new user on signin and that user indeed gets created in the database
3:45:32
but if we try to read that value within the JWT it returns undefined even though the user has been created successfully
3:45:38
in sanity studio and even though we've had an issue with this optional chaining operator that's not to blame even adding
3:45:45
some additional checks like if no user then do something else no that wouldn't
3:45:51
fix it this issue is rooted deeply in how sanity and more importantly nextjs
3:45:57
truly work behind the scenes specifically their caching mechanisms when we first created a new user after
3:46:05
confirming they didn't exist sanity successfully added the user however when
3:46:10
we immediately attempted to retrieve that user within 60 seconds of cre creation the query didn't return any
3:46:17
results this is because the read query was made too soon after the user creation and sanities and next js's
3:46:24
cache hadn't yet been updated this is a common challenge when working with Frameworks or libraries that cash data
3:46:32
and if you're not familiar with how and when caching occurs it can lead to confusion and frustration when queries
3:46:39
don't return the expected results and you know them for a fact that they're there without a proper understanding of
3:46:45
cash you might find yourself stuck and discouraged this is why learning about
3:46:50
cash management is crucial you cannot say you know next GS until you can for a
3:46:56
fact know exactly how its caching mechanism works and within the ultimate nextjs course we dive deep into how
3:47:03
caching works because I know how big of a problem it was for me the developers
3:47:09
that work alongside me on all of these projects and all the other developers out there which are simply saying that
3:47:15
nextjs obscures and abstracts everything and just doesn't work well it's not that
3:47:20
it doesn't work it's that they don't understand it yet so if you're having trouble understanding cash and you want
3:47:27
to dive deeper into its inner workings pause this video and check out the ultimate nextjs Course once you do that
3:47:33
let's go ahead and fix this issue back in our callbacks we have to add use CDN false to both sign in and JWT callbacks
3:47:42
so here where we're calling for existing user we can say say client dot with
3:47:49
config where we can pass the used CDN is set to false and then call a fetch on it
3:47:57
similarly we can pass it when fetching the user right here client dot with
3:48:03
config where we pass in the UCD and false and only then do we fetch if we
3:48:09
now save this close everything because we're expecting it to work go back to San and delete the existing
3:48:17
user log out and give it one final shot let's see what we come up with and
3:48:23
before I log in I'll make sure to clear the cash I'll do it right here clear
3:48:28
cash and clear cookies and all that good stuff you can also do it via inspect element by going to
3:48:35
app and cache finally let's log in okay it
3:48:41
automatically logged Us in which is great the sanity user has been created with all of its great oo GitHub data
3:48:48
that's great but now for the Moment of Truth do we have the session ID within
3:48:54
our terminal and the answer is yes here it is if you didn't know about nextjs
3:49:00
caching you can spend hours on issues just like this because you can see the data for a fact it is here but your
3:49:07
nextjs is telling you that it's not no it's not that nygs is just trying to make sure that your app is as efficient
3:49:14
and as optimized as possible but it's up to you to control the Beast so once
3:49:20
again if this is still a bit unclear and you want a deep under the hood dive into NEX gs's inner workings check out the
3:49:27
ultimate nextjs course more than 4,000 developers have learned from it so far and love it and I'll always continue
3:49:34
updating it with the latest versions of nextjs the link will of course be in the description but with that said even by
3:49:40
watching this video you might already understand some of the intricacies of caching thankfully we have fixed this
3:49:47
issue and we are ready to proceed in the next chapter we'll focus on creating the
3:49:53
create startup page allowing us to create new startups directly from YC directory app not necessarily needing to
3:50:01
go to sanity Studio to start creating the create
Create Startup Form
3:50:06
startup page we have to create a new route in our application for that we'll go to app rout and then Within startup
3:50:15
we'll create a new folder called create and within the create folder we'll create a new file called page. TSX you
3:50:24
know the drill I'll run rafc in there to quickly spin up a simple react
3:50:30
functional component and then I'll head over to create which will bring me to the page that we just created within
3:50:37
here I'll turn this div into an empty react fragment and within it I'll create
3:50:42
a new section this section will have a class name
3:50:47
equal to pinkcore container and m-h Das in square brackets
3:50:54
230 pixels within it we can create a new H1 and give it a class name equal to
3:51:02
heading and within it say submit your startup pitch there we go
3:51:10
that's looking better or we can say submit your startup now right below it we want to have a new component which is
3:51:17
going to be a form so let's go ahead and create that form by creating a new
3:51:23
component in the components folder which is going to be called startup form.
3:51:30
TSX run rafc and then import this form right
3:51:35
below the section as a self-closing component startup
3:51:42
form there we go and of course make make sure to properly
3:51:47
imported perfect there we go it's looking good and we only want to be able to visit this page if we are logged in
3:51:54
so let's add one more fail save by saying const session is equal to await o
3:52:01
coming from next o like this we have to turn this into a sync and then we can
3:52:06
make a check and say if there is no session then we can redirect and this redirect will be imported from next
3:52:13
navigation and it's going to point to just home forward slash
3:52:20
perfect so now if somebody's unauthenticated and they try to manually go to Startup create it'll actually just
3:52:26
bump them up to the homepage because they can view but not create different startups great so now let's dive into
3:52:34
the startup form and let's start implementing it our form will use quite a few different shat CN components so
3:52:40
let's go ahead and install them one by one we can do that by running MPX
3:52:46
shaten add latest add and we can add the
3:52:51
input the text area the toast component which is going to be for little alert
3:52:56
once we submit or once we have an error and we'll add other ones as we go
3:53:02
if we remember to add something else as well now we can develop the UI of the form let's start by turning this entire
3:53:09
div into a form component like this this form will have an action which for now
3:53:14
I'll set to be an empty callback function let's also give it a class name
3:53:20
equal to Startup D form and you notice that as soon as we Define some kind of an action it's going to ask us to turn
3:53:27
this into a client component so let's actually add use client right here at
3:53:33
the top right within the form we'll have a div and we'll use that div just for structuring our elements within the div
3:53:40
we'll have a label with an HTML 4 property equal to title so this will be
3:53:45
a label for the title with a class name of startup D formore label and it's going to say
3:53:53
title right below the label I'll render an input which is going to come directly from shaten meaning add components UI
3:54:01
input like this it's going to be a self-closing component that will have an ID equal to title a name equal to title
3:54:10
a class name equal to Startup Das form on _ input it'll be required and it'll
3:54:18
have a placeholder equal to Startup title there we go that's looking good
3:54:23
right below it we can check whether we have any errors on our form so let's create a new use state right here use
3:54:31
State snippet which we need to import from react and we'll say const errors
3:54:37
and set errors is equal to use State at the
3:54:42
start equal to just an empty object so now if we have any errors so if errors.
3:54:49
tile exist then we'll render a P tag with a class name equal to Startup D
3:54:57
formore error and it'll render errors. tile perfect right now our
3:55:04
typescript is not sure whether title exists on this errors object so what we
3:55:10
can do is specify the type of this Ed state right here before the opening
3:55:16
parentheses and we can set it as record string string so then it'll know that it
3:55:22
contains Different Strings within this object now this is the field for the
3:55:27
title and we might want to replicate this for other fields as well we want to do it for the description we want to do
3:55:34
it for the category image link and then the pitch itself will be the actual markdown but for now let's duplicate
3:55:41
this entire div at least three times so I'll copy this one two
3:55:48
3 there we go let's divide them a bit with some space and the second one will have the HTML 4 description and it'll
3:55:55
say description the input itself will actually be a text
3:56:01
area so let's import it from components text area the ID and the name will of
3:56:08
course be description instead of startup form input it'll be startup form text
3:56:13
area required and placeholder can be something like startup
3:56:19
description there we go for the errors you know the drill it's going to be errors.
3:56:26
description and at the end we will render the errors. description as well
3:56:32
great two inputs done two more to go below description we'll render a label
3:56:39
HTML 4 category startup form label that's going to say
3:56:45
category the input for that category will be category the name will be category as well and we'll say something
3:56:52
like startup category we can give some examples so that they know what they have to enter like Tech health education
3:57:00
and so on and we'll render errors. category and
3:57:07
errors. category here as well and after that we'll have our image link so let's render the HTML 4 Link
3:57:15
and say image URL change the ID to
3:57:20
link the name to link as well and we can say something like startup image
3:57:28
URL and finally we'll render the errors. Link and errors. Link right here as well
3:57:36
and we have four different inputs great now below these we'll need
3:57:41
to have a pitch and this will be the actual markdown which will give us a lot
3:57:46
of different capabilities so we can further optimize and style how we want to portray the pitch of our startup you
3:57:54
can see it in real time how it looks like you can enter different code blocks and you can even enter inline images
3:58:00
which is pretty cool so it gives you a lot of flexibility in how you want to present your startup so to create this
3:58:07
markdown component we'll use UIW react MD editor which is a simple Mark done
3:58:13
editor with preview view implemented with reactjs and typescript let's go ahead and install it together by running
3:58:20
mpmi at UIW SL react D md- editor and
3:58:27
here we can see how it can be used we can import it right here at the top of the file we need to Define its state or
3:58:35
the value in this case I'll rename it from value to pitch and set
3:58:42
pitch that's going to be used State and finally we'll be able to render it like
3:58:47
so so let's scroll a bit down and let's actually duplicate the entire div one
3:58:52
final time for this pitch element but this time we'll give this div a data
3:59:00
color mode and set it to light so it always must be light give it HTML for pitch change this
3:59:09
to pitch we'll remove this input and instead of the input we'll use this empd
3:59:15
editor that we have here we can change the value to pitch and set the onchange to set pitch and for the errors that's
3:59:23
going to be errors. pitch as well as errors. pitch right here in this case I
3:59:29
believe we have to set it as a callback function that gets access to the value
3:59:35
and then we can call the value as string just to make sure that typescript is
3:59:40
happy in this case there we go now now we're good so
3:59:45
if you go back to the create page and reload you should be able to see a very simplistic but nice looking markdown
3:59:52
editor which has the preview mode enabled so you can see exactly what you're doing in real time now let's TI
3:59:58
it further and give it additional features we can give it an ID equal to pitch we can also give it a preview
4:00:06
equal to edit a height of about 300 pixels to give it some more space we can give it a
4:00:13
style of border radius of 20 to make it fit along our
4:00:19
other elements better and an overflow of hidden there we go now it's a bit more
4:00:24
organic we can give it a text area props
4:00:30
specifically change a placeholder to be briefly describe your idea and what
4:00:38
problem it solves and we can also give it a preview options which is an object
4:00:44
where we can set a this allowed elements and we can disallow The Styling so we're
4:00:51
only going to keep the base marked on properties so if we reload and remove this hello world you can see that it
4:00:57
says briefly describe your idea and what problem it solves finally at the bottom below this div let's render a button
4:01:04
coming from components UI button let's give it a type is equal to
4:01:10
submit as it will submit the entire form and a class name equal to Startup D
4:01:15
formore BTN there we go now when submitting this form it'll take some
4:01:22
time it won't be an instantaneous action so let's create a field const is pending
4:01:28
which for now I'll set it to false later on we'll extract this value dynamically
4:01:33
to know whether we're submitting the form or not I'll also remove this hello world from the pitch so we have a clean
4:01:40
and empty slate so going back to the button we can now make it disabled in case it is currently pending
4:01:48
meaning something is happening also if it is pending will change what it says
4:01:54
it'll say submitting dot dot dot else it'll say submit your startup or your
4:02:01
pitch and let's also render a send icon right here which will have a class name
4:02:07
equal to size-6 and margin left of two and we can also get it a text- white so
4:02:16
the contrast is a bit better there we go let's see why this startup form is
4:02:21
complaining it is saying that we have multiple default exports let's see if
4:02:26
that really is the case hm it seems to me like we only have one if I close the file and then reopen it looks like the
4:02:33
error is gone great and with that the UI of her form is looking great so now we
4:02:39
can focus on submitting the form and we'll submit it you using reacts latest
4:02:46
use action State hook a hook that allows you to update the state based on the
4:02:51
result of a form action it is a hook that simplifies the process of managing
4:02:56
form States and form submissions you don't have to write too many used states
4:03:02
it is designed to work seamlessly with server actions allowing you to update component State based on the result of
4:03:08
the form action it even exposes a special is pending state that can be used to show a loading indicator while
4:03:15
the action is being executed and this use action State Hook is even better and
4:03:21
it's aim to replace the react Dom's used form State hook as it caused some
4:03:27
confusion and limitations so this new hook fixes those issues by renaming use
4:03:34
form state to use action state it adds an additional pending State and it moves
4:03:39
the hook to the react package overall a very good update in my opinion so let's
4:03:45
explore it in a bit more detail we import use action State Hook from
4:03:50
react and you use it like you would typical use state but this time instead
4:03:56
of simply saying use State and then getting the value and the setter in this case you're getting the current state of
4:04:02
the form as state you're getting this patch which is the action that we
4:04:08
trigger to dispatch or trigger the form meaning update and then we get is
4:04:13
pending which is a Boolean indicating whether the action is currently pending to this hook you also provide the action
4:04:20
which is a function that is triggered when the form submit you can think of this as handle submit you get the
4:04:27
initial state of the form and then an optional Perma link containing the unique page URL that the form modifies
4:04:35
so with that in mind let's actually add the use action State hook to the code we
4:04:40
can do that right here at the top I'll remove this is pend and I'll say const we can get the state
4:04:48
the form action and the is pending state by saying is equal to use action state
4:04:56
which you call as a function of course we have to import this use action State
4:05:01
as we learned directly from react so we can get it right here to it we need to provide the actual action that'll happen
4:05:09
once we submit the form so let's create it const handle form submit is an arrow
4:05:17
function which we can call right here handle form submit that's the action and
4:05:23
we can also pass the initial state of the form which can be set to an error
4:05:28
which is set to an empty string as well as a status which can be set to initial
4:05:34
like this we can also declare this handle form right here above so we can use it here and we have to fix the typo
4:05:41
in the error right here we'll soon look into this tapescript warning but before that let's focus on the validation of
4:05:48
the form for validation we'll use Zod Zod is a simple typescript first schema
4:05:54
validation with static type inference and to implement it you can create a new
4:06:00
file in our lib folder that's going to be right here and let's call it
4:06:06
validation dots within it you can say export const form schema is equal to Z
4:06:14
doob and then you pass in all of the properties that you want your inputs to have and of course we have to import Z
4:06:22
from Zod so which kind of fields do we have well we have a title right here so
4:06:29
we can set that title to be a z. string with a Min so Min of three
4:06:36
characters and that Max of about let's do 100 characters let's add a
4:06:42
description Z that string. Min let's do something like 20 and 500 so that's
4:06:49
going to be a bit longer let's do a category which can be set to a z. string
4:06:56
as well with a Min three and Max 20 let's add a link which is going to be a
4:07:02
z. string. url. refine where we have a callback
4:07:09
function where you get the actual URL that the User submitted and then you can
4:07:15
do additional checks on it you can open up a new try and catch block which is going to look something like this and we
4:07:22
have to ensure that the URL provided is an actually valid image URL so we can
4:07:28
say constr is equal to await fetch.
4:07:33
URL with a method being set to head so we're not
4:07:38
fetching the actual contents the image we're just fetching the head to get access to its content type so we can say
4:07:45
const content type is equal to rest. headers
4:07:50
doget content-type once we get it we can check
4:07:55
if content type question mark. starts with image slash because it can be image
4:08:03
BNG JPEG and so on if it does we'll return true else will return false and
4:08:12
in the catch will also just return false because something went wrong so we're
4:08:17
doing some more complex validation to check whether the URL is correct and we
4:08:22
can make this function async because we're using a weight right here and it's saying that this if statement can be
4:08:28
simplified sure it can we can just return this because this function starts
4:08:33
with by itself returns true or false so check this out the same if statement can
4:08:39
be written just like this if it starts with it will return true else it will return false finally below the link we
4:08:47
have the pitch which is going to be a z. string of Min 10 characters and that Max
4:08:57
about let's think about it well we don't even have to provide a Max on that one it can be much longer so now we have our
4:09:03
form schema which we're exporting and we can use it back in the startup form so
4:09:09
let's dive into the handle form submit further by first making it accept a
4:09:14
previous state of the form which is going to be of a type any and form data
4:09:20
of a type form data then we can open up a new try and catch
4:09:27
blocks if there's an error we can return that error and we can also give it finally finally happens either way so
4:09:34
which code you want to run when either it fails or it succeeds so let's focus on the try first we can get access to
4:09:41
the form values by saying const form values is equal to an object or we can
4:09:47
specify how can our form data look like we'll get the title by saying form data.
4:09:52
getet title and we can say as string just to make sure that typescript is Happy next we can do a description and
4:10:00
set it to be equal to form data. getet description as a string we can repeat
4:10:06
the same thing for the category and we can repeat the same thing for the link link is form data. getet link as string
4:10:15
and finally we'll just set the pitch like this because we don't need to get it from the form as we're managing it as
4:10:21
a separate individual State now that we have the form values we want to validate those values by saying await form schema
4:10:30
which we just created which we're importing from validation parse
4:10:36
async form values okay so we want to take the form values and we want to
4:10:42
compare them with the form schema to see if they match if they do we can proceed by saying const result is equal to a
4:10:50
wait and here we can call a new mutation called create idea which right now
4:10:57
doesn't exist to which we can pass the pref state the form data and the pitch
4:11:04
for now I will comment it out and right below it we'll want to console log the result just to see how
4:11:11
well it works since we're using a weight here we have to turn this into a sync
4:11:17
and you can see that now tapescript is not complaining about the initial state but rather to use action State it'll fix
4:11:23
once we finish working on the handle form submit but for now we want to test out whether we actually get all of the
4:11:29
necessary values from the form when we submit it so let's actually consol log
4:11:34
the form values and save it we can give it a shot by filling all of these values
4:11:39
we'll have to sometimes use longer values because because we do have some validation put in place I'll enter test
4:11:47
right here and actually I'll enter htps colum test.com to see whether this will
4:11:54
succeed and we have some fake pitch so let's click submit it's
4:12:01
submitting okay check this out it cleared the form and said please check your input and try again pretty cool we
4:12:09
failed on the description and we failed because the URL wasn't a valid image
4:12:15
this was a pretty cool validation to be honest what we did for the image you can completely refine your validation and
4:12:21
you can do some more complex checking like the one we're doing here by checking whether this is an image or not
4:12:27
so now let's try to fill this properly by entering a few more characters here entering a category and I'll find some
4:12:34
image URL online such as by going to the deployed website and picking one from
4:12:40
here let me go with this one right here copy image address and I can paste it
4:12:47
and I'll enter just a test for the pitch right now and I'll make it a bit larger
4:12:53
there we go I'll bold it and give it a horizontal Rule and one horizontal rule
4:12:58
at the top okay let's submit our pitch submitting success your idea has been
4:13:06
created successfully oh this was not what we were supposed to take a look at I mean I mistakenly submitted the form
4:13:13
on the finished version of the YC directory app not the Local Host 3000 so
4:13:19
let's actually test it here but before that let's actually validate our inputs
4:13:24
we can do that by going into the catch right here and checking if error is an
4:13:31
instance of Z do Zod error like
4:13:37
this and we have to import Z coming from Zod there we go now this allow us to
4:13:43
check for the errors if it is an instance of that we then want to get
4:13:49
access to specific field Errors By setting that equal to error. flatten so
4:13:56
we'll flatten them all in a single array and say field
4:14:02
errors then we want to set errors to be equal to field errors as
4:14:10
unknown as record that'll have a string and string so this
4:14:16
is just for tab script to be happy and then we can return a previous state and
4:14:23
modify the error to say validation failed with a status equal
4:14:32
to error all uppercased like this so now we're properly throwing errors if it's
4:14:39
some other kind of error so not an instance off error right here then we
4:14:44
can just return the previous state the error saying something like an
4:14:50
unexpected error has occurred and then we can set the status to be set to error
4:14:59
great so now we're handling the catch and I don't even think we'll need the finally so I'll remove it for now so now
4:15:06
we can check whether the validation actually works I'll enter some things
4:15:11
right here category click submit okay we have to add a URL and if we click submit
4:15:19
nothing really happens it just clears the entire form oh and I think I know
4:15:24
why that is this function is never actually getting called because if you check the action of the form we're not
4:15:32
actually passing the form action which is the handle form submit so what we need to do is pass the form action right
4:15:39
here as the action that way when we submit the form this handle submit
4:15:44
function will actually be ran so let's one more time try to submit it with form
4:15:49
action like this and let's click submit it's submitting and there we go
4:15:56
now we get invalid URL input perfect that means that the validation is
4:16:01
actually working in case something goes wrong we can also show a shat CN toast
4:16:07
that'll be a little alert component saying that something went wrong to make that happen let's let's go to our
4:16:15
layout and this will be the layout not within the root but the general layout
4:16:20
this one right here and there right below the children we can add the
4:16:25
toaster component coming from components UI toaster and now back in the startup
4:16:30
form we can render a specific toast by first of all getting access to it at the top const toast is equal to use toast
4:16:40
which we have to import from hooks use toast and now we can trigger it at different point of our application such
4:16:48
as when there is an error when we set the errors we also want to show a toast that will have a title equal to
4:16:56
error it'll also have a description something like please check your inputs
4:17:01
and try again and we'll have a variant of destructive which means that it'll be a red error we can also copy it and
4:17:09
duplicate it right here below for or an unexpected error so that it can execute
4:17:16
before the return here we can just say an unexpected error has
4:17:22
occurred great finally we'll also do another toast if everything goes right
4:17:28
so right here below the Consol log of success we can say if result.
4:17:35
status is triple equal to success all uppercased then we can show a toast
4:17:43
that's going to say success with a description equal to your
4:17:49
startup pitch has been created successfully and below that once that
4:17:54
happens we actually want to reroute to that startup Details page so let's import the use router right here at the
4:18:01
top by saying const router is equal to use router coming from next navigation
4:18:08
and then right here below we can say router. push pointing to forward slash
4:18:16
startup SL result. ID because that's going to be the ID of our new startup
4:18:23
that's going to be within if result is Success so let's put it here and finally
4:18:28
we'll just return result to know that everything went right but for now we
4:18:33
want to comment this out because we don't yet have a function a mutation that will actually create the idea for
4:18:39
now we just want to see whether we get up to this point of the application where we actually get access to the form
4:18:45
values the user is trying to submit and I have to comment this part out so now
4:18:51
that we have the toaster and everything let's give it a shot I'll try to make it
4:18:56
fail One More Time by providing fake info and clicking submit yeah we can see
4:19:02
the description fails the image URL fails and the string must contain at least 10 characters fails as well so
4:19:10
let's now fix this I'll take in some some actual titles and descriptions like
4:19:15
skill Forge a platform that uses AI to create custom learning paths for individuals based on their
4:19:22
goals I'll also take a real image URL category can be something like edte
4:19:30
educational technology and for pitch details I will also take some prettier
4:19:36
looking markdown we can see how that looks like right here let's make sure to properly
4:19:43
bolded there we go this is looking better so let's click submit now and as
4:19:49
you can see we got a new conso log in the startup form that gave us all the information that we just filled in which
4:19:55
means that it's properly getting through we have a category description link pitch and a title everything needed to
4:20:02
actually submit a startup which means we are ready to take this form data and pass it into a new server action called
4:20:09
create idea which will submit that startup and we'll do that in the next lesson but for now let's sum up what
4:20:16
we've learned in this one you'll learn how to use the newest use action State hook that allows you to update the state
4:20:23
of the form based on the result of a form action it Returns the state the form action and the is pending State and
4:20:30
to it you have to pass the submit Handler the initial State and another optional parameter but as with anything
4:20:37
in life it has its good and bad sides L Rob one of the public developer ERS ad
4:20:43
verell who's teaching about react nijs and the web shared his views on the Ed
4:20:49
action State The Good The Bad and The Unknown react 19 is making data
4:20:54
mutations easier you can call an action on the client or server and have built in hooks for pending States handling
4:21:01
errors optimistic updates and more you're able to write less user code a lot of which was previously boilerplate
4:21:08
and hopefully can create better uis with these abstractions the good being that one of the hooks you can call is called
4:21:14
use action State and if you're using the nextjs app router you might have seen the use form state but now that is the
4:21:21
updated version of that as we've learned overall the hook works well as intended
4:21:26
and definitely contains less code than you would typically need for a form but there are also some downsides like it
4:21:33
feels like it's fighting typescript often when you move from calling a form directly to using use action State this
4:21:39
changes the function signature export Asing function save action to export async function save action with the
4:21:46
previous state and the new form data not a big deal right but something that is a bit of a bigger deal especially for me
4:21:53
is that I haven't yet figured out the most common use cases regarding the previous state but one of the bigger
4:22:00
downsides for me is that server actions will automatically reset the form on submission which is nice sometimes but
4:22:08
not always what you want which is what you were able to see in our case as soon as we submit it it actually cleared all
4:22:15
the fields exactly what he says next if there's an error in your action and you return some object you ideally don't
4:22:21
want to blow away the client side values in your form instead you want to retain those values and maybe show an error
4:22:28
message under the input since the default behavior is to reset the form you have to save all of the form input
4:22:33
values into use action State and then derive those values from that state in the component so with that in mind I'm
4:22:40
sure that the use action state will evolve and grow but for the time being it is definitely a welcomed Improvement
4:22:47
in how we're dealing with forms in the newest versions of react and
Server Action
4:22:52
nextjs to submit our startup we'll have to do it through a mutation through a
4:22:58
server action server actions can be defined by using react use server
4:23:03
directive you can place them at the top of an async function or Mark the entire
4:23:09
file as use server something like this where you can have multiple server actions in a single file understanding
4:23:15
server actions is still incredibly relevant in all new versions of nextjs and if you don't really know what a
4:23:22
server action is I go into much more depth about them in this video which I'll link below teaching you how to
4:23:28
develop serers side applications with server actions and even teaching you how to build a simple application using them
4:23:35
so pause this video and watch this first if you don't really know what the heck are server actions but if you do know a
4:23:42
bit about them and you want to proceed right away that's totally okay we can do that let's go over to lib and create a
4:23:49
new file called actions. TS within there as you know you can
4:23:57
immediately put a use server directive at the top because all of these functions will be rendered on the server
4:24:05
so let's create our first server action by exporting it and declaring it as create idea or you can call it create
4:24:13
pitch I think that makes a bit more sense and let's set it equal to an async
4:24:19
function that looks something like this it'll accept a
4:24:25
state as any and form as form
4:24:31
data as well as a pitch itself of a type string next we also have to get info
4:24:38
about the user who is submitting it so let's get access to the active session by saying session is equal to await o
4:24:46
and we need to import o coming from next off or rather add for
4:24:52
SL off if there is no session we can just return an object with an error saying
4:25:01
not signed in and a status of error but you can just return objects like this
4:25:09
what you have to do is wrap them in json. pars but first they have to be
4:25:15
wrapped in json. stringify like this so just so we don't repeat this Json parse
4:25:21
Json stringify every time let's actually create a new utility function right
4:25:27
below the format date we can say export function parse server action response
4:25:35
which will be of a type T it'll take in a response of a type t as well and it'll
4:25:43
return json.parse json. stringify and then whatever
4:25:48
response we pass into it now this allows us to very easily call it and wrap any
4:25:55
object we want to call directly with this new utility function which we have created perfect now that we have covered
4:26:02
the edge case if our user is not authenticated let's try to destructure
4:26:07
all the values from the form by saying const title
4:26:13
description category and the link is equal to object Dot from entries because
4:26:20
it's all within an object and then out of that we can form array Dot from form
4:26:28
and we want to filter each property where key is not equal to pitch so we
4:26:35
only want to keep the pitch even though this might seem a bit complicated it's the simplest way that I found it that
4:26:40
works we keep the title The description category in the link and then we get the pitch from here finally we also have to
4:26:47
form a slug and a slug is basically a unique identifier for that specific
4:26:53
startup you could generate it randomly but I found this package called slugify
4:26:58
which is very minimal works very well it just basically creates a meaningful slug
4:27:03
for each post so let's simply install it by running mpm install slugify and we
4:27:11
can say con is equal to slugify to which we can pass title as string and we can
4:27:18
provide additional options as lower is true and strict is true as well finally
4:27:25
now that we have all the info such as the title description category link pitch and then the slug as well we can
4:27:32
open up a try and catch block let's first handle the catch where we're going
4:27:38
to consol log the error so we know that something went wrong and we'll also
4:27:43
return a parse server action response where the error will be equal
4:27:50
to json.stringify error and the status will be set to
4:27:55
error and now for the try we have everything needed to form a startup so
4:28:01
let's do that con startup is equal to an object that has a title a
4:28:09
description a category an image which is going to be a link a slug of a type Slug
4:28:18
and current value of slug make sure you put the underscore here for the type we
4:28:23
also have the author so we have to connect the startup to the author which is going to be underscore type is equal
4:28:30
to reference and the actual underscore ref will point to the session question mark.
4:28:36
ID which is the ID of our author and finally the pitch which is the mark.
4:28:42
content let's see if slugify has been imported properly we have to say import
4:28:47
slugify from slugify there we go and now we can write to
4:28:55
sanity client to create it by saying const result is equal to await write
4:29:02
client. create a document with an underscore type equal
4:29:09
to Startup and we will simply spread out all of the startup values directly
4:29:15
within this document which we're creating within the object once we get the result we can simply return a parse
4:29:22
server action response where we spread out the result error will be set to an
4:29:28
empty string and Status will be set to success there we go so basically what
4:29:35
we're doing is this we are getting the necessary params such as the form data
4:29:41
and the pitch which is also kind of like form data but it's in a bit of a different format in markdown or a string
4:29:48
in this case then we extract this session because we need to know who is
4:29:53
the author of the startup we check whether a session exists we extract all
4:29:58
the values from the form we create a slug we take all of those pieces of data
4:30:04
including the form data the generated slug the author and the pitch itself and
4:30:10
we write to sanity to actually create it in the database and then we return it
4:30:15
back and this is called create pitch so now we can go back to the startup form
4:30:22
and we can uncomment our lines right here but instead of create idea I'll
4:30:28
rename it to create pitch and there we go I don't think I even need to consol
4:30:33
log the result or the form values because we will see the toast hopefully
4:30:39
and we'll be redirected to that startup detail if the creation is successful so let's
4:30:44
go ahead and test it together one more time I will use the values from a real startup skill Forge which is an AI
4:30:52
platform that uses AI to create learning paths I'll grab in the image address and
4:30:58
the category can be set to something like edtech and finally I will add the pitch
4:31:04
details right here and maybe make this skill Forge a bit larger let's see there
4:31:11
we go this is looking good so let's submit our pitch it's
4:31:18
submitting and we got redirected to a 404 which is a good thing because for a
4:31:24
second there we saw your startup was created successfully if you head over to localhost 3000 Studio you should be able
4:31:32
to see skill Forge or in your case whatever title you used indicating that the new startup has been successfully
4:31:39
created from the form within our application and it should already be visible on the homepage but I'm
4:31:45
wondering why didn't redirect us to The Details page of that startup well it's because the URL says undefined that
4:31:52
means that this result ID was also undefined so why is that oh the result
4:31:59
has an underscore ID and not an ID so this little fix should actually make it
4:32:04
work great but for now let's manually navigate to homepage and hopefully the
4:32:09
new startup will appear right here there we go keep in mind that it can take up to 60 seconds and you might need to
4:32:16
clear the cache because it's pulling it from a CDN but once it actually updates you can see it here you can go to its
4:32:23
Details page and would you look at that we have successfully created a real
4:32:29
startup and if you reload you should be able to see that the number of views is one and it'll continue increasing great
4:32:36
I'll quickly head back over to sanity Studio to delete the fake startups we
4:32:41
had created with a fake user so it was just Adrien not a real user so let's go
4:32:47
ahead and delete these three documents because we now have the
4:32:52
possibility to create new ones coming directly from the platform there we go and I'll delete
4:33:00
this one as well finally we can go under authors and you can delete this fake author that we
4:33:06
have initially created because now we have real one authenticated with next author
4:33:12
using GitHub ooth and with that we only have one startup we have the ability to
4:33:18
search for startups skill Forge there we go or we can clear it and we can now
4:33:23
create startups the majority of the functionality has already been implemented but of course we'll continue
4:33:30
until this actually feels like a real SAS application that allows entrepreneurs to pitch their startups so
4:33:37
if you want to take a bit of a pause now would be a perfect time to do so you deserved it take a pause go for a walk
4:33:45
or go to sleep if watching this late at night and come back
Performance & Bug Tracking in Next.js Apps w/ Sentry
4:33:50
soon now that some of our apps major functionalities have been successfully implemented it's time to make sure that
4:33:57
hundreds of thousands of users that will use them don't break them and to make sure that doesn't happen we'll use
4:34:04
Sentry the best application monitoring software considered not bad by more than
4:34:10
4 million Developers click the link in the description to follow along and see exactly what I'm seeing then create your
4:34:17
account once you do you'll be redirected either to the dashboard or to the onboarding if you're already using
4:34:24
sanity to track your production level applications like I am then you'll be in your dashboard but in this case we want
4:34:30
to start from scratch so in your url after your Sentry account name simply type on boarding which will open up this
4:34:37
nice welcome to Sentry your code is probably broken maybe not not let's find out on boarding process so let's go
4:34:45
ahead and click install Sentry choose nextjs as your framework of choice and
4:34:51
let's configure it together you'll have to copy this command and then head over to package Json and in the same way that
4:35:00
we have overrides for react and react Dom versions I'll add another override
4:35:05
for the version of nextjs so simply say next dollar sign next this will ensure
4:35:12
that Sentry uses the same version of nextjs that we're using in our project now you can open up the
4:35:20
terminal and paste the command we copy from sanity right here feel free to change the name of the project in our
4:35:26
case I'll use YC directory and press enter then press y or enter say that we
4:35:34
do have a Sentry account and you can choose this project right here and click continue There we go you can select the
4:35:41
existing project and Sentry is being installed with mpm it'll then ask you
4:35:47
whether you want to Route Sentry requests in the browser through an xgs server in this case I'll say no as this
4:35:53
can increase the server bill it's not like we're going to get charged or anything as Sentry has a very generous
4:35:59
completely free tier but it's nice how they said we'll leave this option commented for later just in case I swear
4:36:06
Sentry has one of the best developer experiences out there do you want to enable react and an notations in this
4:36:12
case we can say sure yeah do it do you want to enable tracing yep why not
4:36:18
Sentry session replay yep let's enable it do you want to create an example page
4:36:24
yes let's do it are you using cicd tool yeah we'll be using versell later on so
4:36:29
let's say yes and it's giving us a Sentry o token which you can copy now and press yes continue and there we go
4:36:37
successfully installed the Sentry nextjs SDK you can validate your setup by
4:36:42
restarting your Dev environment and then visiting Sentry example page so let's do
4:36:47
just that I'll head over to Local Host 3000 SL centy Das example- page and there we go
4:36:55
this is a page that was added to our application by Sentry and for the first time ever I'm going to purposefully
4:37:01
throw an error just to make sure that Sentry is actually watching over us and alerting us about those errors there we
4:37:09
go error has been thrown and now at the bottom you can see error received so let's check out the error in our project
4:37:15
dashboard and there we go it might take up to a minute for this error to appear but there we go sentury example error
4:37:23
four events priority high and you can now get into it to see more details
4:37:28
first of all you're getting additional information on where this error happened unhandled Sentry example API route error
4:37:36
and here's what's cool about it right now sure we could debug this error they directly within our browser or dive into
4:37:43
code and fix it super simple right but the problem occurs when a user breaks
4:37:50
your application and typically no matter how much you test users will always end
4:37:56
up breaking it so when they do break it imagine how painful it is to ask them to
4:38:01
open up the console and send out a screenshot of what they're seeing then they're not going to copy and paste it
4:38:07
they're going to take a photo of it with their phone and debugging it will be super hard so for that reason Sentry
4:38:15
simplifies tracking and resolution of those errors by giving you event highlights of how the error has happened
4:38:22
it happened in the development environment on this specific URL by doing this specific transaction on this
4:38:30
specific browser we can also see the line of code pointing to that error and even the version of the operating system
4:38:37
and the device that a user was using it also gives some additional information such as as the browser version device
4:38:44
architecture I mean this is pretty crazy stuff that's going to allow you to debug
4:38:49
your applications much more simply and think about it 100 users are going to have 100 different devices and 100
4:38:55
different browsers so being able to track first of all and then debug just
4:39:00
makes your applications so much more scalable you can also view the full Trace right here and see exactly how the
4:39:07
error has happened and for some types of issues like this Cent example frontend
4:39:13
error you can actually check out the replay there it is so if I play it first of all you can see that all the
4:39:19
characters are just asterisks because Sentry wants to protect the privacy of the user breaking your site but you can
4:39:26
still see what they were doing at the moment when they actually broke it you can see exactly which pieces of UI they
4:39:33
were clicking with which headers and on which URL that allows you to go back to
4:39:38
the code and fix it once you deploy a hot fix just go ahead and click resolve
4:39:44
but of course as the application grows and gets more users as we can see right here you'll get so many monitoring and
4:39:50
tracking features provided to you by Sentry simply put you can see which Pages your users are breaking the most
4:39:57
this Trace view is super useful of course I don't even have to mention how useful the replays are for example let's
4:40:04
check out the user that had most dead clicks and let's set the time span to last 30 days let's check out this user
4:40:11
for example this one is a bit crazy Windows 10 plus on the Opera browser they were actually exploring the
4:40:17
healthcare application that I created not that long ago you can see exactly what they were doing even though
4:40:23
everything is completely blurred so if the error has occurred we would have known we can see exactly which elements
4:40:30
they were clicking and and we can also see what was happening in the console and the network tab of their browser
4:40:36
this makes the debugging process super simple along replays there's also performance that allows you to track how
4:40:43
quickly certain pages are loading for your users so that way you can figure out if some pages are loading slowly for
4:40:50
whatever reason you can also very quickly add a user feedback model so that good users that don't break your
4:40:56
application can report bugs on their own as a matter of fact let's go ahead and add it together right now I'll simply
4:41:02
click setup now and we just have to add this part to the Sentry client config so
4:41:08
let's copy this entire thing head over to Sentry client config and under
4:41:13
Integrations along replay we can also add this one here Sentry do feedback
4:41:21
integration if you do that and go back to your application check this out a new report a buug floating button appeared
4:41:28
at the bottom right you can click it enter your name and email add a screenshot of the bug and then say the
4:41:36
search isn't working for me just an example and we can send the bug report
4:41:41
in an instant then if you go back to the user feedback part of your dashboard and reload you can immediately see a new
4:41:48
ticket raised right here the search isn't working for me but it's not like you're only getting this text or a
4:41:54
screenshot you're getting much more like the URL they were on the replay that was happening before they actually sent the
4:42:01
message and all of the things that we have explored previously such as browser and more information and you can also
4:42:07
immediately track this issue in jira GitHub or any other platform there's also some generic stats so you can see
4:42:14
how good your app is behaving but in general that is it I don't want to bore you with a lot of other details what I
4:42:20
really wanted to say is that if you only add Sentry to your app for which the setup literally took like 10 presses of
4:42:27
the enter key and 3 minutes already you're making your app so much more secure less error prone and more bug
4:42:35
free and if this is looking too good to be true I mean let's check out their pricing for s devs working on small
4:42:42
projects it is completely free you're one user and you get all the error monitoring and tracing that we talked
4:42:49
about if you're going to be the only Dev using it that's more than enough so great job implementing Sentry and making
4:42:56
our app that much more bug-free for our users to enjoy I was planning to end this chapter here but then I stopped
4:43:02
recording and went to check out my email and I just had to show this to you as well while we were testing and our users
4:43:10
were breaking the app Sentry actually sent out an email alerting us about
4:43:15
those issues in real time so as soon as the error happened we immediately got
4:43:21
all the important information about the error including the tags we talked about earlier letting us know exactly what
4:43:27
broke so this is the type of thing that if you're running a serious SAS application and there's a breaking bug
4:43:34
you want to be able to fix it as soon as possible so it's good to know that this is offered too now onto the next chapter
User Profile
4:43:43
next let's create a user profile route we can do that by opening the file
4:43:49
explorer going to root and creating a new folder called user within it create
4:43:56
another folder called ID within the square brackets this is a dynamic route
4:44:01
as you already know and then create a new file called page. DSX run RFC inside
4:44:09
of there and as soon as you save it you'll be able to click on your profile to actually navigate you to a profile
4:44:16
page there we go so before we start with the UI let's actually fetch the user
4:44:21
details right here at the top I will destructure the params of this page and
4:44:27
I'll specify the type perams is going to be of a type perams which is a promise
4:44:34
that contains an ID of a type string something like this then we we can extract the ID from
4:44:42
it by saying ID is equal to await per
4:44:48
rams. ID and since we're using a weight we have to add a sync right here next we
4:44:54
can get the session by saying con session is equal to a wait o and we also
4:45:00
have to import o from add SLO next we can fetch the user by saying
4:45:07
const user is await client. not fetch and this client of course is referring
4:45:14
to a sanity client and we have author by GitHub ID query to which we're going to
4:45:21
pass the ID finally we can check if a user doesn't exist we can return a not
4:45:28
found which is going to navigate us to a404 but as you can see here we get a404
4:45:34
this query isn't really going to cut it it's getting the author by GitHub ID which is called ID but in here we have
4:45:42
to get a user by its own ID by the author ID so let's duplicate this entire
4:45:48
query and let's just rename it a bit to getting the author by ID query and we're
4:45:58
going to refer to the underscore ID property so the only thing we have to change is this underscore ID once you do
4:46:06
that and replace this query and remove the one that we just imported
4:46:11
you'll see that now we'll still be on the same page without getting redirected to a
4:46:16
404 that means that we actually have the user and we can start creating the UI
4:46:21
for the user Details page let's start by turning everything into a react fragment
4:46:27
within which we will have a section this section will have a class name equal to
4:46:34
profile uncore container and within this section we'll have another div with a
4:46:40
class CL name equal to profile card and within it we'll have
4:46:46
another div with a class name equal to profile undor title within which we will
4:46:54
have an H3 element that'll have a class name equal
4:46:59
to text- 24- Black uppercase and text- center and ending it
4:47:07
with line clamp one so it doesn't go into multiple rows within there we can render the user.name
4:47:14
if I save this we get this funky UI that says Adrian JS Mastery for you it's
4:47:20
going to be something different and if you're wondering how did we accomplish the styles to achieve this funky UI you
4:47:26
can just search for profile title or profile card and see exactly which styles are getting applied now let's go
4:47:33
below the H3 and below the div and create a next GS image this image will
4:47:39
have a source equal to user. image with an ALT tag of user.name
4:47:45
a width of 220 a height of 220 and a
4:47:51
class name of profile uncore image and there we go this one got pulled directly
4:47:57
from my GitHub this is kind of a face reveal I'm standing right here next to my GitHub star at the GitHub Universe
4:48:04
conference going below this image let's render a P tag with a class name equal
4:48:10
to text- 30 extra bold margin top of
4:48:16
seven and text- Center we can render at and then user question mark. username
4:48:22
perfect right below this P tag let's create another P tag with a class name
4:48:27
of margin top of one text- Center and text -4- normal within which we can render
4:48:35
user question mark. bio in this case you should be able to see nextjs and iast
4:48:41
and educator for you it's going to be something else let's go below this div and let's create another div with a
4:48:49
class name equal to flex D1 Flex
4:48:56
flex-all gap of five and then extra large devices minus margin top of five
4:49:03
within which we can render a P tag with a class name equal to text D30 - bold
4:49:11
and there if the session question mark. ID is equal to the ID of the currently
4:49:17
logged in user then we can say your else we can say all and then we can render
4:49:25
the word startups So currently I am on my profile
4:49:30
and you'll be able to see your startups but if we were on somebody else's profile you would be able to see other
4:49:37
startups or rather all startups next we can render a UL which is an unordered
4:49:43
list with a class name of cardor grid
4:49:48
DSM and here we'll render a list of this user's startups so user startups and
4:49:57
we'll do that very soon but before we do I want to explain that this is the
4:50:02
perfect use case for PPR all the user info you're seeing here such as the name
4:50:09
username bu and profile photo can be statically rendered for a longer time
4:50:15
but the user created startups have to be dynamic so here we'll want to enable PPR
4:50:22
I'm going to go right at the top and say export const experimental undor PPR is set to true
4:50:30
and I think you can slowly start seeing the exact use cases where PPR might come
4:50:35
in handy whenever you have some static data like we have explored the the product
4:50:41
details before but recommended products because they have to be recommended by some kind of dynamic algorithm or maybe
4:50:48
Dynamic shipping those things have to be dynamic same thing here the new user startups have to be
4:50:56
dynamic so now let's create a new component in the components folder and I'll call it user
4:51:05
startups do DSX I'll run rafc
4:51:12
and I'll import it right here in this unordered list I'll render user startups
4:51:19
as a self-closing component and you can see it appear right here now that we have this component we also have to
4:51:25
create a query that would allow us to fetch all the startups created specifically by that user so let's copy
4:51:33
one of the startup queries it can be this one here startup squarey the first one we have ever created copy it
4:51:41
paste it right here below rename it to
4:51:46
startups by author query here we're searching for a startup but now we're
4:51:53
going to remove this part all the way up to here yeah we're going to remove this
4:51:59
entire part we're just going to keep the order okay so we're going to say and author
4:52:07
doore ref is equal to do sign ID so we're comparing it to the author we're
4:52:14
searching for and we will still order it created at descending and then we want
4:52:19
to return all of the information that we previously returned great so now we can
4:52:25
copy the name of that and go back and we can import it right here by saying const
4:52:31
startups is equal to await client referring to sanity client.
4:52:38
fetch startups by query and then we pass the ID of the
4:52:44
author we're searching for and how do we get the ID into this component well we
4:52:49
can pass it as a prop ID is equal to ID so we can very quickly get it right here
4:52:55
through props by saying ID and specifying that this ID is of a type
4:53:01
string since we're using a weight we have to turn this into a synchronous
4:53:07
function and we get access to startups right here finally we can return an empty react
4:53:15
fragment where we're checking if startups that length is greater than
4:53:22
zero then we can return posts or startups do map where we get each
4:53:29
individual startup of a type startup card type which we'll have to import and
4:53:36
for each one we automatically return just by using parenthesis is a startup
4:53:43
card a startup card has to get a key because we're mapping over it of post do
4:53:49
dollar Sun ID and the post itself which will be equal to Startup now let's
4:53:55
properly import the startup card type which can come right here from startup
4:54:00
card let's see how did we call it in there startup type card there we go I fixed it and here I'm going to also
4:54:07
refer to this as a startup doore ID and of course we have to have the
4:54:13
second part of the turnery which is going to just render a P tag with a class name of no result and it'll say no
4:54:22
posts yet let's make sure that we properly indented right here there we go
4:54:28
I got it let's see why is it complaining I'll try to reload the server to see if that fixes it oh but
4:54:36
the error is still there and you know what this might be
4:54:41
we missed one thing we're doing a fetch right here and we're using it within a PPR component but we might need to wrap
4:54:48
this newly created component into react suspense because this will take some
4:54:53
time to load so first we need to show a fullback for it so let's create a suspense
4:55:00
component with a fullback equal to a P tag off loading dot dot dot and now we
4:55:08
can put user startups within it and there we go that fixed it but it
4:55:13
brought back the issue so that means the issue is still somewhere here within user startups maybe we messed up the
4:55:20
query while copying it we're starting with this square bracket here but we're
4:55:25
never actually ending it so let's end it here and save it and there we go we
4:55:32
immediately get back our startup and as you reload you'll see that the top part loads immediately but right here at the
4:55:38
bottom there's a quick loading that appears and instead of Simply showing the text that says loading let's
4:55:45
actually install a shaten skeleton component a skeleton component is a
4:55:50
grade out rectangle that makes it appear like the entire div is
4:55:55
loading it looks so much better it makes the user wait a bit longer for it to load so let's run
4:56:01
MPX shaten at latest add skeleton looks
4:56:07
like we have already added it before so let's head over to the startup card and
4:56:13
right at the bottom of it we can say export con startup card
4:56:19
skeleton and we can have an instant return where we return a react fragment
4:56:26
where we map over let's say 1 2 3 4 five
4:56:31
maybe different cards by saying that map we get the first element and the index
4:56:38
of that element which is a number and for each number we return An Li of
4:56:44
key is equal to CN which we have to import from utils
4:56:49
skeleton and then the index as a matter of fact our numbers are actually indices so we can just use the first parameter
4:56:57
of the map as an index and we can pass it here that's going to be of a type number and then within it we can render
4:57:04
a skeleton component coming from components UI skeleton with a a class
4:57:11
name equal to Startup Das cardor skeleton now we're exporting it
4:57:18
and we can go back to our user Details page and we can use it right here
4:57:24
instead of the loading startup card skeleton it's going to look like this so
4:57:29
now if you reload you should be able to see something that resembles a card appear
4:57:35
before the card actually appears maybe if I go to inspect element and I go to
4:57:41
network and I turn on slow 4G maybe we can see the loading appear now that was
4:57:48
still too fast well what if I do command shift R which is going to clear the cache as well it's super fast maybe even
4:57:54
too fast to be able to see it but there we go for a second there as I reloaded or a millisecond while the card was
4:58:01
loading you were able to see this one right here now I can notice that we forgot to replace the Avatar right here
4:58:08
because this one was created by the the new Avatar so let's actually fix it by
4:58:13
going over to Startup card and we'll search for where we show the Avatar
4:58:18
image right here instead of this Source we can rather render author question mark. image and now we can see a real
4:58:25
image appear right here that's much better and we can render the author name as the AL tag for it perfect this is
4:58:34
great so would you look at that this is our second page where we used partial
4:58:40
pre-rendering to show user details statically and then to dynamically render new startups that that user has
4:58:48
posted looking great now one thing that I think we forgot to do at the start was
4:58:54
to update the navigation bar to be a bit more mobile responsive so if I go to
4:59:00
mobile view or rather collapse it like this you'll see that it doesn't really fit
4:59:06
all the way like it does in tablets but not on smaller mobile devices so let's quickly go back to the Navar
4:59:13
and let's find the button where it says create right here let's give it a class name on Max SM it'll be completely
4:59:21
hidden so you can see it will disappear but now below it we can show a
4:59:27
log out icon which will have the exact opposite
4:59:32
class it'll be a size of six but on small devices it'll be hidden
4:59:40
and it'll have a text red 500 so now we'll have a little logout icon this
4:59:47
doesn't go under create this actually goes under log out so let me put it right here below this logout button and
4:59:55
for it we have to do the same thing as we have done above turn it into a span so I'll copy this create and I'll just
5:00:02
make it say log out there we go below the create span we can create a
5:00:07
different icon this time it'll be a badge plus
5:00:12
icon once again with a class name is equal to size of six and then SP devices
5:00:20
hidden and finally we can also replace the user Avatar here where we show the user avator name instead of the full
5:00:27
name let's rather render the image shat CN has a perfect component for that so
5:00:33
let's run MPX shat and latest add
5:00:38
Avatar that'll allow us to remove this span and instead of it render avatar
5:00:45
coming from components UI Avatar with a class name equal to size is set to 10
5:00:53
within it we'll have an avatar image also coming from components UI Avatar
5:00:58
it'll be self-closing and it'll have a source equal to session question mark.
5:01:03
user question mark. image let's fix this class name spelling and and let's give
5:01:10
this Avatar an ALT tag of session question mark. user mark. name or an
5:01:17
empty string in case we don't have it same thing here or an empty
5:01:23
string and below it we can also render something known as an avatar
5:01:28
fullback coming from components UI Avatar which will allow us to render
5:01:33
some kind of a foldback if the image is not there we can say something like AV for Avatar let's fix this this class
5:01:40
name right here and there we go we have a great looking Avatar Photo and now if
5:01:46
you expand it a bit you can see now it's a bit different yes the Avatar is showing but now it says create log out
5:01:53
and then smaller devices we can see the icons great work coming this far into
5:01:58
the video in the next lesson I'll show you how to add another great
Final Feature, Parallel Fetching and Deployment
5:02:04
feature do you know about the website called Awards the one that recognizes and promot great websites well I'll
5:02:11
teach you how to implement a feature to our YC directory app similar to what awards has if you head over to explore
5:02:19
you'll notice that there are many different categories like honorable mentions nominees site of the DAT site
5:02:25
of the Year side of the month and more well these are in simple words playlists
5:02:30
or some kind of categories of different startups or different designs whatever it may be so let's Implement that into
5:02:37
our app as well different kind categories of startups we can do that by first creating a new schema in sanity
5:02:46
schema types and create a new file and call it playlist. TS to create it we can
5:02:53
copy what we have in startup there we go and then paste it in the playlist and
5:02:59
make the necessary adjustments such as let's name it playlist give it a name of
5:03:06
playlist a title of playlists it'll be of a type document and then we can
5:03:12
Define different fields I'll delete a few of these as we only need three in this case the first one will be a title
5:03:20
string the title of the playlist the second one will be a slug and the third one will be a select which is a type of
5:03:30
array like this and it is going to be an array of different references so we can say
5:03:38
type is reference and a reference to what you may ask well
5:03:43
a reference to a type of startup that's going to look something like this so
5:03:50
what do I mean by this well each playlist will refer to multiple startups
5:03:56
and it'll have its own title like startups of the day or startups of the year so as soon as you do that let's
5:04:02
head over to index.ts and let's add playlists or
5:04:07
playlist right here as the third type importing
5:04:13
playlist from schema types playlist if you save it you can rerun your
5:04:18
application and then head over to sanity Studio once you're there you can click this create button and create a new
5:04:25
playlist you can give it any name you like such as best pitches or startup of
5:04:31
the day or something like editor picks so startups that YC directory admins
5:04:37
have liked the most we can generate cre a slug and now you can select different startups you want to add to this
5:04:44
playlist and see how simple this is you can just refer to different ones like skill Forge in this
5:04:50
case and that's it it'll automatically be saved I'll pause the video for a second to create a few more startups
5:04:57
just so we have some more startups to choose from and while I'm adding startups you can also add some additional pitches too there we go I
5:05:04
went ahead and added a few more startups now typically it'll take 60 second for
5:05:10
the cache to reload or you can just hard reload it and there we go so now I can
5:05:15
actually add a few more startups right here to editor picks I'll add JS Mastery
5:05:21
Pro and I'll add events sphere and I'll click save at the bottom
5:05:28
right there we go our editor picks have been published now we have to write a query that fetches the playlists by the
5:05:35
slug so let's head over to queries and let's write one last query
5:05:42
considering that we already wrote quite a couple I'll actually provide this one to you in the read me of this
5:05:48
video so you can just paste it here the name will be playlist by slag
5:05:54
query and it'll search for documents of theore type playlist where a slug exists
5:06:02
and then it's going to return everything including all the necessary info for the startups within that playlist
5:06:10
great we want to show these editor picks on the startup Details page but you can really put it anywhere you could also
5:06:16
render it right here below the all startups but for the time being I'll render them below the details of a
5:06:23
specific startup so right here below so let's copy the name of the
5:06:28
query and let's head over to Startup details so that is going to be this page
5:06:33
right here which is under app Root startup ID and the reason why
5:06:40
we're doing this here is because I want to show you a special feature so first things first let's say const the
5:06:48
structure select as editor posts or editor startups is equal to await
5:06:56
client. fetch where we pass in the query and then we can also pass the slug that
5:07:02
you're trying to fetch in this case I called it editor pick new for you most
5:07:08
likely it's going to be editor pick once you do that you can go below to where we
5:07:13
left are to do right here and you can check if editor posts question mark.
5:07:20
length is greater than zero then we want to render a div with a class name equal
5:07:28
to Max dw- 4XL and margin X of
5:07:33
Auto A P tag that'll have a class name equal to text D30 - semi bold and it'll
5:07:41
say editor piix right here we can render a UL an
5:07:46
unordered list with a class name of margin top of seven and a cardor grid of
5:07:54
small like this within it we want to map over editor posts by saying that map
5:08:00
where we get each individual post which is of a type startup type card and we
5:08:07
also get the index of a type number and for each one we want to Simply return a
5:08:12
startup card that's going to look something like this with a key equal to index and a post equal to post but make
5:08:19
sure to First import the startup card and we can just call index I there we go
5:08:26
and immediately you should be able to see however many posts you have chosen as editor picks this is great as now
5:08:33
editors can go directly in sanity studio and choose their favorite startups now allthough this works and it is fine we
5:08:41
have a little issue and that is that we have to be aware of two different data
5:08:47
fetching patterns parallel and sequential when fetching data inside components you need to be aware of those
5:08:54
two patterns so as you can see in sequential one is happening after the
5:09:00
other one two one 2 one2 so it's trying to load both of the things first for the
5:09:08
root layout then for the second page and then for the third page one by one but
5:09:13
in parallel it's actually loading one thing for all the pages and then it's slowly loading the other which takes
5:09:20
much less time as you can see here in sequential requests in a component tree are dependent on each other which can
5:09:28
lead to longer loading times but in parallel requests in a route are eagerly
5:09:33
initiated and will load data at the same time which reduces the total time it takes to load data
5:09:39
what we have done just now is sequential we're first fetching the data about the post and only then we're fetching the
5:09:46
editor posts so what does this mean well this means that we first fetch the post data and only after that is complete
5:09:54
then we fetch the editor picks but the time to fetch both will increase as it
5:09:59
will be the sum of both of these requests this approach is great if the second request depends on the first one
5:10:06
but in this case they're completely independent so we can take advantage of these modern
5:10:12
systems that are capable of handling multiple requests concurrently so let me teach you how to
5:10:19
implement parallel requests it's going to look something like this you'll say const and then do array D structuring
5:10:27
and say this is equal to await promise.all promise that all allows you
5:10:34
to pass two different calls and then for each one you get the result right here D
5:10:40
structured so the first call is going to be this one client fetch startup by ID
5:10:46
query so let's copy it and let's add it as the first element in the array the
5:10:52
second one will be this one client fetch playlist by slug so let's copy it and
5:10:58
add it as the second one great and now we can just get the result of both of
5:11:03
these at the start we first get the post and then for the second one we can these
5:11:09
structure this select editor posts and now we can remove both of
5:11:15
these two independent ones as we have just one that does everything this way
5:11:20
by using promise that all the code makes two independent requests concurrently
5:11:26
and as a result the total time is roughly equal to the duration of the longest request not the sum of
5:11:34
both by doing this your application's performance will increase and low times
5:11:40
will be even faster compared to making sequential requests as you can see it is
5:11:46
super fast I cannot even see something is loading so now you know a bit about a difference between parallel and
5:11:52
sequential rendering in xjs understanding the basics can make a big difference when you know how to fetch
5:11:59
data in parallel or use PPR to handle both Dynamic and static content on the
5:12:05
same page you don't just make your website faster and better you also grow
5:12:10
from a beginner to a senior developer you'll develop the decision-making skills every company wants knowing which
5:12:18
technology to use when to use it and most importantly why and that's why I've
5:12:23
included many theoretical Concepts tips tricks and things I wish I knew when I
5:12:28
was first learning nextjs in the ultimate nextjs course you'll dive deep
5:12:34
into strategies like caching revalidation backend routes serverless functions Edge run times react server
5:12:41
components inner workings handling parallel and sequential requests and using the latest features from react 19
5:12:49
and NEX 15 I've made sure to cover everything along with a build and deploy
5:12:54
of a modern stack Overflow clone covering all of these features so today
5:13:00
I'm publishing the nextjs 15 version of the ultimate nextjs course loved by over
5:13:07
4,100 Developers who keep messaging me about how this course help them become
5:13:13
the best nextg developer in their team at work or get them freelance opportunities and no it's not just a few
5:13:20
new lessons of next 15 it's an entirely new course fully re-recorded packed with
5:13:26
even more features such as next off for authentication Deep dive into the new
5:13:31
PPR strategy improved database architecture more secure server actions
5:13:37
testing using playwright email notifications search engine optimization tips and tricks and much more with a
5:13:44
special dedicated Discord Channel where we answered every single one of the answers from all 4,000 developers see it
5:13:52
for yourself so don't delay your nextjs dreams and become the best nextjs developer by taking the ultimate nextjs
5:13:59
course we have a super sale going on right now which only happens about once a year so visit jm.pro
5:14:09
SL nextjs and join more than 4,000 developers on this journey I hope I'll
5:14:14
see you in the course but for now let's go ahead and finalize this application I noticed that when creating
5:14:20
a startup we are issuing a toast a toast notification so let me show you how that
5:14:26
looks like if we go to the startup form we are sending this success toast
5:14:35
specifically this one but I noticed that sometimes it lacks the background ground so let's try to initiate it by default
5:14:42
by simply adding it right here at the top and of course closing it properly if
5:14:48
you reload you can see it at the top it's missing the background so let's go
5:14:53
to a toast component which you can find by going to the components
5:14:58
folder and then UI and then toast I'm actually glad this
5:15:05
happened because I can show you how we can further modify chatsi and component onon let's head over to this line right
5:15:12
here let's give it a BG white text- slate
5:15:18
d950 on dark mode BG slate 950 and on dark mode text slate 50 so
5:15:27
we're just changing the text color and the background color if I reload this fixes it and it's looking so much better
5:15:35
so now we can go back and remove this fake toast and and with that in mind I
5:15:40
believe our application is done I can go ahead and test it a bit by checking the
5:15:45
search Yep this works do we have a word that is shared amongst all of these well
5:15:52
I guess just the author is shared so if I go for Adrian y we can see that it finds all of them if I go for
5:15:59
event no nothing but event sphere yeah this is good what if I
5:16:06
search for Pro yep that works so search is working
5:16:12
everything is working and this app is utilizing the latest and greatest of what react and next GS have to
5:16:19
offer so the last step in every single JavaScript Mastery video is deployment
5:16:25
so let's go ahead and deploy it to the internet together to deploy it you can head over to your GitHub and create a
5:16:31
new repository call it something like YC directory either make it public or
5:16:37
private and click create then let's stop it from running and let's follow all of
5:16:43
these steps get init get add dot git commit DM first
5:16:51
commit git Branch dasm main get remote add
5:16:57
origin oh in this case I already have one so I'll rename it to origin one and
5:17:03
get push U origin main once you do that the code will be
5:17:09
live on your repo which means that we can head over to versell and create a new project out of this new repo that we
5:17:16
just added so let's go to import don't forget to add environment variables so
5:17:23
back in our code we have our env. loal copy all of these variables and then
5:17:31
paste them right here and we also have the Sentry o token as well so let's copy
5:17:37
it and add it as well not to forget it so let's click deploy now when deploying
5:17:43
big applications such as this one especially after doing so many changes it is highly likely and actually
5:17:51
probable and expected that something will go wrong and that it won't be deployed on the first time so we can
5:17:57
make additional changes later but that's not a problem if it breaks we'll fix it
5:18:02
so let's give it some time and I'll be right back and after 2 minutes and 50 seconds it broke thankfully it is just a
5:18:11
couple of typescript warnings which is not a big deal you can go ahead and fix those typescript issues in your project
5:18:18
or it's also totally okay to disable them for production builds so that's exactly what we'll do in this case to
5:18:25
get our project deployed the only thing you have to do is say tab script ignore build errors to
5:18:31
true and you can do that within next config so let's head over to next config
5:18:37
and let's add script ignore build errors is set to
5:18:43
True similarly we can do the same thing for eslint by saying ignore during builds is
5:18:50
set to true now you can open up the terminal run
5:18:55
git add dot git commit DM update next
5:19:01
config and then run git push as soon as you do that and go back to your resell
5:19:07
dashboard if you go to your project and go to deployments you should be able to see that the update next config push is
5:19:15
building fingers crossed and there we go the deployment succeeded so if you go to project and click visit you can see that
5:19:22
our application loads but there is a slight error a client side exception
5:19:27
error specifically so if you go to the console you can see that sanity is being
5:19:33
blocked by the Court's policy so let's head over to our project dashboard go to
5:19:40
API go to course origin and add a course origin for our newly deployed URL we can
5:19:48
do that by copying the URL from the app and let's allow credentials and click
5:19:54
save now if you go back and reload it all works you might have thought that we broke something else but no we just had
5:20:01
to allow it another thing which you'll have to allow is GitHub oath remember to
5:20:07
redirect URI you'll have to take the URL of the current application head back to
5:20:12
the O settings for this app and then update the homepage URL as well as this
5:20:19
URL right here htps YC directory. L.A or
5:20:25
whatever your url is and then leave the rest the same click update application
5:20:31
go back reload and click log in one more time and would you look at that it
5:20:36
logged Us in automatically so to finish this great video off let's create one
5:20:42
final startup actually the startup title will be the YC directory
5:20:48
itself we're so proud of it so let's say that this is a
5:20:54
directory of great startup pitches created by the
5:21:01
community category is going to be something like business we can take some
5:21:07
kind of an image from May YC combinator so I'll just grab the image
5:21:12
address and paste it and we can say something like no pitch needed right
5:21:20
here this app speaks for itself and let's submit the pitch oh it
5:21:27
looks like the image wasn't valid and it cleared our form that's actually One
5:21:33
update that I would like you to make play with the new react hook that we used to submit the form and try to
5:21:39
repopulate the fields if the submission fails but no worries I've took another
5:21:44
image and I'll say YC directory hopefully this time it works and I'll
5:21:51
click submit there we go your startup pitch has been submitted we can see it
5:21:56
right here which means that all of our apps functionalities are
5:22:01
working and it still didn't appear on the homepage because these results are cached and it can take up to 60 seconds
5:22:09
to appear right here beautiful this was such a wonderful build in which we
5:22:15
explored the latest and greatest of what react NEX GS and Sanity have to offer
5:22:21
and if you came to the end of this video and you still didn't take the ultimate next GS course I really think you're
5:22:27
going to love it considering that you watched all the way until the end of this amazing crash course as I already
5:22:34
told you in this ultimate course we dive much deeper into the intricacies of how
5:22:40
nygs truly works under the hood we optimize performance to this and we do a
5:22:46
lot of deep Dives to truly understand how things work behind the scenes as well as build an app that is much more
5:22:53
complex than the app you've built in this video so considering that you're watching here after a couple of hours of
5:22:59
content and you're still here I really think it's a good fit for you I'll leave the link down in the description with
5:23:04
that said thank you so much for watching and I'll see you in the next one have a wonderful day

